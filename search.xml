<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深度学习基础原理知识整理</title>
      <link href="/2025/05/05/%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/05/05/%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="全连接神经网络学习笔记"><a href="#全连接神经网络学习笔记" class="headerlink" title="全连接神经网络学习笔记"></a>全连接神经网络学习笔记</h1><h2 id="全连接神经网络的整体结构"><a href="#全连接神经网络的整体结构" class="headerlink" title="全连接神经网络的整体结构"></a>全连接神经网络的整体结构</h2><p>全连接神经网络整体架构分为输入层、隐藏层和输出层三层</p><ul><li><p>输入层：用于接受原始数据。每个神经元代表一个特征，例如图像的像素值、语音信号的特征等。</p></li><li><p>隐藏层：处理和提取数据特征。每个神经元通过加权和激活函数来处理输入数据，然后将结果传递到下一层。</p></li><li><p>输出层：给出最终的预测结果。输出层的神经元数目等于任务的类别数。例如，在数字分类任务中，输出层有10个神经元（分别代表0到9这10个数字）。</p></li></ul><p><img src="https://s2.loli.net/2025/04/22/tOvW3KfRB9QjZcy.png" alt="全连接神经网络总体结构"></p><h3 id="全连接神经网络的结构单元"><a href="#全连接神经网络的结构单元" class="headerlink" title="全连接神经网络的结构单元"></a>全连接神经网络的结构单元</h3><img src="https://s2.loli.net/2025/04/28/sqMpd28AtHPJmIE.png" alt="全连接神经网络单元结构" style="zoom:80%;" /><p>神经元的数学表达式如下所示：<br>$$<br>a=h(w<em>x+b)<br>$$<br>其中 h() 就是激活函数，若隐去h() ，$w</em>x+b$ 就是线性回归模型的函数表达式，若 h() 是 sigmod 函数，则变成逻辑回归模型的函数表达式。</p><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>激活函数是神经元最重要的组成部分，往往存在于神经网络的输入层和输出层之间，作用是给神经网络中增加一些非线性因素，使得神经网络能够解决更加复杂的问题，同时也增加神经网络的表达能力和学习能力。如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，最终的输出都是输入的线性组合。 <strong>激活函数给神经元引入了非线性因素，使得神经网络可以任意逼近任何非线性函数</strong>。</p><h3 id="Sigmoid-函数"><a href="#Sigmoid-函数" class="headerlink" title="Sigmoid 函数"></a>Sigmoid 函数</h3><p>公式与导数如下所示：<br>$$<br>y=\frac{1}{1+e^{-z}}\Rightarrow y’=y(1-y)<br>$$<br>其函数图像与导数图像如下所示：</p><p><img src="https://s2.loli.net/2025/04/28/8yQxWnO9dgJBUM1.png" alt="sigmoid函数图像"><img src="https://s2.loli.net/2025/04/28/DbygT8BALocNzdW.png" alt="sigmoid导数图像"></p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>简单、非常适用分类任务；</li><li>输出区间为 (0,1)，方便观察输出是否符合预期，适合作为概率模型的输出</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>反向传播训练时有梯度消失的问题；</li><li>输出区间为 (0,1)，关于 0 不对称，导致参数 w 更新较慢；</li><li>梯度更新在不同方向走得太远，使得优化难度增大，训练耗时</li></ol><h3 id="Tanh-函数（双曲正切函数）"><a href="#Tanh-函数（双曲正切函数）" class="headerlink" title="Tanh 函数（双曲正切函数）"></a>Tanh 函数（双曲正切函数）</h3><p>公式与导数如下所示：<br>$$<br>y=\frac{e^z-e^{-z}}{e^z+e^{-z}}\Rightarrow y’=1-y^2<br>$$<br>其函数图像如图所示：</p><p><img src="https://s2.loli.net/2025/04/28/EtqynTfsFVgKS2Q.png" alt="Tanh函数图像"></p><p>可以看出 Tanh 函数的取值范围为 [-1,1]。</p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol><li>解决了 Sigmoid 函数输出值非 0 对称的问题；</li><li>训练比 Sigmoid 函数快，更容易收敛</li></ol><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>反向传播训练时有梯度消失的问题；</li><li>Tanh 函数和 Sigmoid 函数非常相似，虽然解决了 Sigmoid 函数输出值非 0 对称的问题，但仍然存在饱和问题</li></ol><h3 id="ReLU-函数"><a href="#ReLU-函数" class="headerlink" title="ReLU 函数"></a>ReLU 函数</h3><p>公式和导数如下所示：<br>$$<br>y=<br>\begin{cases}<br>    z &amp; z&gt;0 \<br>    0 &amp; z\leq0 \<br>\end{cases}<br>\Rightarrow<br>y’=<br>\begin{cases}<br>    1 &amp; z&gt;0 \<br>    0 &amp; z\leq0 \<br>\end{cases}<br>$$<br>其函数图像与导数图像如下所示：</p><p><img src="https://s2.loli.net/2025/04/28/o9VMmZGUzl6ywBE.png" alt="ReLU函数图像"><img src="https://s2.loli.net/2025/04/28/goTDr1lLFM32GBE.png" alt="ReLU函数图像"></p><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ol><li>在X &gt; 0 时，由于导数为 1，链式法则连乘也不会导致梯度消失，解决了梯度消失的问题；</li><li>计算方便，不存在 Sigmoid 函数和 Tanh 函数的指数计算，计算速度快 ，加速了网络的训练</li></ol><h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>由于负数部分恒为0，大的学习率会导致一些神经元永久性死亡，无法激活（可通过设置小学习率部分解决）；</li><li>输出不是以0为中心的</li></ol><p><strong>PS：</strong>关于大的学习率导致“神经元永久性死亡”如何理解，首先我们知道参数更新是通过$W=W-αW’$，若学习率 α 太大，会导致 W 更新后为负数，当输入某个正值时，会导致其与 W 相乘后仍然为负值，此时激活函数输出为 0，而此时的导数也为 0，下次反向传播链式法则更新参数时，由于梯度为 0，W 将永远得不到更新。</p><h3 id="LeakReLU-函数"><a href="#LeakReLU-函数" class="headerlink" title="LeakReLU 函数"></a>LeakReLU 函数</h3><p>公式和导数如下所示：<br>$$<br>y=<br>\begin{cases}<br>    z &amp; z&gt;0 \<br>    az &amp; z\leq0 \<br>\end{cases}<br>\Rightarrow<br>y’=<br>\begin{cases}<br>    1 &amp; z&gt;0 \<br>    a &amp; z\leq0 \<br>\end{cases}<br>$$<br>其函数图像如下所示：</p><p><img src="https://s2.loli.net/2025/05/08/GlCP7rpIN3v5Uqs.png" alt="LeakReLU函数图像"></p><h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h4><ol><li>具有 ReLU 激活函数的优点；</li><li>解决了 ReLU 函数会杀死一部分神经元的情况</li></ol><h4 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>无法为正负输入值提供一致的关系预测（不同区间函数不同）</li></ol><h3 id="SoftMax-函数"><a href="#SoftMax-函数" class="headerlink" title="SoftMax 函数"></a>SoftMax 函数</h3><p>公式和导数如下所示：<br>$$<br>y_i=\frac{e^{z_i}}{\sum_j e^{z_j}}\Rightarrow y_i’=y_i(1-y_i)<br>$$<br>SoftMax 函数的值域是在 [0,1] 之间的，并且存在多个输出，例如一个三分类任务，那么 SoftMax 函数最终的输出是对应每个类别的概率，同时这三个类别对应的概率相加最终的结果为 1 。因此在多分类任务的场景下，神经网络的最后一层一般都是使用 SoftMax 函数作为激活函数。</p><h2 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h2><p>神经网络的输出是通过前向传播最后输出的，前向传播是将数据特征作为输入，输入到隐藏层，将数据特征和对应的权重相乘同时再和偏置进行求和，将计算的结果通过激活函数进行激活，将激活函数输出值作为下一层神经网络层的输入再和对应的权重相乘同时和对应的偏置求和，再将计算的结果通过激活函数进行激活，不断重复上述的过程直到神经网络的输出层，最终得到神经网络的输出值。</p><img src="https://s2.loli.net/2025/04/30/5IJV4Hg9mwebMzY.png" alt="前向传播" style="zoom:80%;" /><p>举例前向传播计算过程：<br>$$<br>a_{11}=sigmoid(x_1w_{11}+x_2W_{13}+b_1)\<br>a_{12}=sigmoid(x_1w_{12}+x_2W_{14}+b_2)\<br>a_{21}=sigmoid(a_{11}w_{21}+x_{12}W_{22}+b_3)\<br>y=a_{21}<br>$$</p><h3 id="前向传播具体计算过程"><a href="#前向传播具体计算过程" class="headerlink" title="前向传播具体计算过程"></a>前向传播具体计算过程</h3><p>这里利用一个简化的例子和具体的数值，推导计算辅助理解整个前向传播过程，同时可以借助该例对后续反向传播内容理解提供推导验算实例。</p><p><img src="https://s2.loli.net/2025/05/08/rgJKb1CH4B6G8ht.png" alt="前向传播实例"></p><h4 id="具体计算过程："><a href="#具体计算过程：" class="headerlink" title="具体计算过程："></a>具体计算过程：</h4><p>假设，初始化值为 $w_{11}=0.5$， $w_{21}=1$， $b_1=0.5$， $b_2=1$， $x_1=1$，$label=2$。<br>$$<br>a_{11}=sigmoid(1\times0.5+0,5)=0.731\<br>a_{21}=relu(0.731\times+1)=1.731\<br>y=1.731<br>$$</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="均方差损失函数"><a href="#均方差损失函数" class="headerlink" title="均方差损失函数"></a>均方差损失函数</h3><p>$$<br>J(x)=\frac{1}{2m}\sum_{i=1}^m(f(x_i)-y_i)^2<br>$$</p><h3 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h3><p>$$<br>J(x)=-\frac {1}{m}\sum_{i=1}^{m}[y_i\log \sigma(w^Tx_i+b)+(1-y_i)\log (1-\sigma(w^Tx_i+b))]<br>$$</p><h2 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h2><h3 id="单变量链式法则"><a href="#单变量链式法则" class="headerlink" title="单变量链式法则"></a>单变量链式法则</h3><p>假设，当 y 为 u 的函数。u 为 v 的函数，v 为 x 的函数，求 y 关于 x 的导数。具体的公式应当如下所示：<br>$$<br>\frac{dy}{dx}=\frac{dy}{du}\frac{du}{dv}\frac{dv}{dx}<br>$$</p><h4 id="算例："><a href="#算例：" class="headerlink" title="算例："></a>算例：</h4><p>存在函数 $z=u^2$，同时 $u=2-y$，$y=4x$，求 z 关于 x 的导数。按链式求导法则有：<br>$$<br>\begin{aligned}<br>\frac{dz}{dx}&amp;=\frac{dy}{du}\frac{du}{dv}\frac{dv}{dx}\<br>             &amp;=2u\times(-1)\times4\<br>             &amp;=-8u<br>\end{aligned}<br>$$<br>同时：<br>$$<br>u=2-y,y=4x\<br>u=2-4x<br>$$<br>因此：<br>$$<br>\begin{aligned}<br>\frac{dz}{dx}&amp;=-8u\<br>             &amp;=-8\times(2-4x)\<br>             &amp;=32x-16<br>\end{aligned}<br>$$</p><h3 id="多变量链式法则"><a href="#多变量链式法则" class="headerlink" title="多变量链式法则"></a>多变量链式法则</h3><p>假设，变量 z 为 u，v 的函数，u 和 v 分别为 y 的函数，y 为 x 的函数，求 z 关于 x 的导数。具体的公式应当如下所示：<br>$$<br>\frac{\partial z}{\partial x}=\frac{\partial z}{\partial u}\cdot\frac{\partial u}{\partial y}\cdot\frac{\partial y}{\partial x} + \frac{\partial z}{\partial v}\cdot\frac{\partial v}{\partial y}\cdot\frac{\partial y}{\partial x}<br>$$</p><h4 id="算例：-1"><a href="#算例：-1" class="headerlink" title="算例："></a>算例：</h4><p>存在函数 $z=u^2+v^3$，同时 $u=2-y$，$v=4+y$，$y=4x$，求 z 关于 x 的导数。按链式求导法则有：<br>$$<br>\begin{aligned}</p><p>\frac{\partial z}{\partial x} &amp;= \frac{\partial z}{\partial u}\cdot\frac{\partial u}{\partial y}\cdot\frac{\partial y}{\partial x} + \frac{\partial z}{\partial v}\cdot\frac{\partial v}{\partial y}\cdot\frac{\partial y}{\partial x}\<br>    &amp;= 2u\times(-1)\times4+3v^2\times1\times4\<br>    &amp;= -8u+12v^2</p><p>\end{aligned}<br>$$</p><p>同时：<br>$$<br>u=2-4x,v=4+4x<br>$$<br>因此：<br>$$<br>\frac{\partial z}{\partial x} = 192x^2+542x+176<br>$$</p><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>前向传播是神经网络通过层级结构和参数，将输入数据逐步转换为预测结果的过程，实现输入与输出之间的复杂映射。而反向传播算法利用链式法则，通过从输出层向输入层逐层计算误差梯度，高效求解神经网络参数的偏导数，以实现网络参数的优化和损失函数的最小化。</p><p>接下来利用之前学习前向传播过程时的简单例子推导演算反向传播的实现过程辅助理解。</p><p><img src="https://s2.loli.net/2025/05/07/mFz2B1fXij78IDT.png" alt="反向传播具体实例"></p><h4 id="具体计算过程：-1"><a href="#具体计算过程：-1" class="headerlink" title="具体计算过程："></a>具体计算过程：</h4><p>假设，初始化值为 $w_{11}=0.5$， $w_{21}=1$， $b_1=0.5$， $b_2=1$， $x_1=1$，$label=2$。通过前向传播计算得出 $y=1.731$，而 $label=2$，现在利用前向传播计算出来的输出值和真实值 label 之间的误差反向传播来进行梯度更新。</p><p><strong>参数 w<del>21</del> 、b<del>2</del> 的求解：</strong><br>$$<br>\begin{aligned}<br>\frac{\partial J(w_{21})}{\partial w_{21}} &amp;= \frac{\partial J(w_{21})}{\partial y}\cdot\frac{\partial y}{\partial a_{21}}\cdot\frac{\partial a_{21}}{\partial w_{21}}\<br>    &amp;= \frac{\partial \frac{1}{2}(y-2)^2}{\partial y}\cdot\frac{\partial a_{21}}{\partial a_{21}}\cdot\frac{\partial relu(a_{11}w_{21}+b_2)}{\partial (a_{11}w_{21}+b_2)}\cdot\frac{\partial(a_{11}w_{21}+b_2)}{\partial w_{21}}\<br>    &amp;= (y-2)\times1\cdot\frac{\partial relu(a_{11}w_{21}+b_2)}{\partial (a_{11}w_{21}+b_2)}\cdot\frac{\partial(a_{11}w_{21}+b_2)}{\partial w_{21}}\<br>    &amp;= (y-2)\times a_{11}\times \frac{\partial relu(a_{11}w_{21}+b_2)}{\partial (a_{11}w_{21}+b_2)}<br>\end{aligned}<br>$$<br>由于 $a_{11}w{21}+b=1.731&gt;0$，所以 $\frac{\partial relu(a_{11}w_{21}+b_2)}{\partial (a_{11}w_{21}+b_2)}=1$ </p><p>最终<br>$$<br>\begin{aligned}<br>\frac{\partial J(w_{21})}{\partial w_{21}} &amp;= (y-2)\times a_{11}\<br>    &amp;=(1.731-2)\times 0.731\<br>    &amp;=-0.196639<br>\end{aligned}<br>$$<br>同理可得出：$\frac{\partial J(b_2)}{\partial b_2}=-0.269$</p><p><strong>参数 w<del>11</del> 、b<del>1</del> 的求解：</strong><br>$$<br>\begin{aligned}<br>\frac{\partial J(w_{11})}{\partial w_{11}} &amp;= \frac{\partial J(w_{11})}{\partial y}\cdot\frac{\partial y}{\partial a_{21}}\cdot\frac{\partial a_{21}}{\partial a_{11}} \cdot\frac{\partial a_{11}}{\partial w_{11}}\<br>    &amp;= \frac{\partial \frac{1}{2}(y-2)^2}{\partial y}\cdot\frac{\partial a_{21}}{\partial a_{21}}\cdot\frac{\partial relu(a_{11}w_{21}+b_2)}{\partial a_{11}}\cdot\frac{\partial sigmoid(x_1w_{11}+b_1)}{\partial w_{11}}\<br>    &amp;= (y-2)\times1\cdot\frac{\partial relu(a_{11}w_{21}+b_2)}{\partial (a_{11}w_{21}+b_2)}\cdot\frac{\partial(a_{11}w_{21}+b_2)}{\partial a_{11}}\cdot\frac{\partial sigmoid(x_1w_{11}+b_1)}{\partial w_{11}} \<br>    &amp;= (y-2)\times w_{21}\cdot \frac{\partial sigmoid(x_1w_{11}+b_1)}{\partial w_{11}}\<br>    &amp;= (y-2)\times w_{21}\times sigmoid(x_1w_{11}+b_1)(1-sigmoid(x_1w_{11}+b_1)x_1)\<br>    &amp;= (1.731-2)\times 1\times 0.731 \times(1-0.731)\times1\<br>    &amp;= -0.269\times 0.731\times 0.269\times1\<br>    &amp;= -0.052895<br>\end{aligned}<br>$$<br>同理可得出：$\frac{\partial J(b_1)}{\partial b_1}=-0.052895$</p><p><strong>对应参数的梯度：</strong><br>$$<br>\frac{\partial J(w_{21})}{\partial w_{21}}=-0.196639,\frac{\partial J(b_2)}{\partial b_2}=-0.269,\<br>\frac{\partial J(w_{11})}{\partial w_{11}}=-0.052895,\frac{\partial J(b_1)}{\partial b_1}=-0.052895<br>$$<br>为了方便计算，以下全部保留三位小数，设置学习率大小为 0.1，则 <strong>更新参数</strong> 如下：<br>$$<br>w_{11}=0.5-0.1\times(-0.053)=0.505\<br>w_{21}=1-0.1\times(-0.197)=1.020\<br>b_1=0.5-0.1\times(-0.053)=0.505\<br>b_2=1-0.1\times(-0.269)=1.027<br>$$<br>由该组新参数前向传播得：<br>$$<br>a_{11}=sigmoid(1\times 0.505+0.505)=0.733\<br>a_{21}=relu(0.733\times1.02+1.027)=1.775\<br>y=1.775<br>$$<br><strong>结论：</strong></p><p>此时最终的输出结果为 $y=0.1775$ ，可以看出这个数值比初次前向传播得出的输出值 1.731 更接近真实值 2.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习基础原理知识整理</title>
      <link href="/2025/04/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2025/04/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习基础原理知识整理"><a href="#深度学习基础原理知识整理" class="headerlink" title="深度学习基础原理知识整理"></a>深度学习基础原理知识整理</h1><h2 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h2><h3 id="线性回归模型定义"><a href="#线性回归模型定义" class="headerlink" title="线性回归模型定义"></a>线性回归模型定义</h3><p>假设给定数据集 ( D = {(x<sub>1</sub>, y<sub>1</sub>), (x<sub>2</sub>, y<sub>2</sub>), … , (x<sub>m</sub>, y<sub>m</sub>)} )，其中 x<sub>i</sub> = (x<sub>i1</sub>; x<sub>i2</sub>; … ; x<sub>id</sub>)，$x<del>i</del> \in \mathbb{R}$。线性回归就是试图学得一个线性模型，尽可能准确地预测实际输出值。通俗地讲，即求属性与结果之间的线性关系。<strong>线性回归模型</strong>的函数表达式为：</p><p>$$<br>f(x) = w_1 x_1 + w_2 x_2 + \cdots + w_n x_n + b<br>$$</p><p>也可以用向量形式表示为：</p><p>$$<br>f(x) = w^T x + b<br>$$</p><p>从上述公式可知，线性回归模型要求得一组最优的 w<del>i</del> 和 b ，以确定线性模型，使其无限逼近数据 x<del>i</del> 与结果 f(x<del>i</del>）之间的关系。  </p><h3 id="误差函数"><a href="#误差函数" class="headerlink" title="误差函数"></a>误差函数</h3><p>假设有一单特征线性模型数据输入只有一个，将模型简单确定为：<br>$$<br>f(x)=wx+b<br>$$<br>为了方便理解和计算将模型化简一下，只用一个 w 来表达输入和输出之间的关系（这样做并不严谨，只是为了方便后面计算），因此现在模型简化为了 $f(x)=wx$ 。</p><p>现在用一个公式计算输出与真实值间的误差：<br>$$<br>loss=(f(x)-y)^2=(wx-y)^2<br>$$<br>数据肯定有不止一个，要计算所有数据真实值和输出之间的误差并计算出平均值，这个函数为均方误差函数，也是线性回归模型的<strong>损失函数</strong>。<br>$$<br>J(x)=\frac{1}{2m}\sum_{i=1}^m(f(x_i)-y_i)^2<br>$$</p><h3 id="线性回归模型参数求解——最小二乘法"><a href="#线性回归模型参数求解——最小二乘法" class="headerlink" title="线性回归模型参数求解——最小二乘法"></a>线性回归模型参数求解——最小二乘法</h3><p>现在我们需要找到一个方法帮助我们找到一个合理的 w ，对这个 w 求解。Loss值计算公式：<br>$$<br>loss=(f(x)-y)^2=(wx-y)^2<br>$$<br>求解Loss的最小值：<br>$$<br>\begin{aligned}<br>\frac{\partial Loss}{\partial w}&amp;=\frac{\partial(wx-y)^2}{\partial w}\<br>&amp;=2(wx-y)\frac{\partial (wx-y)}{\partial w}\<br>&amp;=2(wx-y)x<br>\end{aligned}<br>$$<br>令导数为0，求得：<br>$$<br>w=\frac{y}{x}(x不为0)<br>$$</p><h4 id="最小二乘法——向量形式"><a href="#最小二乘法——向量形式" class="headerlink" title="最小二乘法——向量形式"></a>最小二乘法——向量形式</h4><p>线性回归模型的向量表达式如下式所示：<br>$$<br>f(x)=w^Tx+b<br>$$<br>为了方便原理的同时也方便计算，我们将参数 b 纳入到矩阵 <em><strong>w</strong></em> 中，此时数据特征矩阵 <em><strong>x</strong></em> 则为：<br>$$<br>X = \begin{pmatrix}<br>x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d} &amp; 1 \<br>x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d} &amp; 1 \<br>\vdots &amp; \cdots &amp; \ddots &amp; \vdots &amp; \vdots \<br>x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{md} &amp; 1 \<br>\end{pmatrix}<br>$$<br>矩阵 <em><strong>w</strong></em> 为：<br>$$<br>w = \begin{pmatrix}<br>w_1\<br>w_2\<br>w_3\<br>\vdots\<br>w_m\<br>b<br>\end{pmatrix}<br>$$<br>得到线性回归模型的向量表达式如下式表示：<br>$$<br>f(X)=Xw<br>$$</p><p>显然 <em><strong>X</strong></em> 和 <em><strong>w</strong></em> 都是一个矩阵，利用最小二乘法对这个矩阵求最优的 <em><strong>w</strong></em> 矩阵参数：<br>$$<br>\begin{aligned}<br>J(w) &amp;= \frac{1}{2}(J(w)-Y)^2\<br>     &amp;= \frac{1}{2}(Xw-Y)^2\<br>     &amp;= \frac{1}{2}(Xw-Y)^T(Xw-Y)\<br>     &amp;= \frac{1}{2}(w^TX^T-Y^T)(Xw-Y)\<br>     &amp;= \frac{1}{2}(w^TX^TXw-Y^TXw-w^TXY+Y^TY)<br>\end{aligned}<br>$$</p><p>针对 <em><strong>J(w)</strong></em> 求导数，补充下列矩阵求导公式：<br>$$<br>\frac{\partial AB}{\partial B}=A^T, \frac{\partial A^TB}{\partial A}=B,\frac{\partial X^TAX}{\partial X}=2AX<br>$$<br>依据求导公式对函数进行求导：<br>$$<br>\begin{aligned}<br>\frac{\partial J(w)}{\partial w} &amp;= \frac{1}{2}(\frac{\partial w^TX^TXw}{\partial w}-\frac{\partial Y^TXw}{\partial w}-\frac{\partial w^TX^TY}{\partial w})\<br>    &amp;= \frac{1}{2}[2X^TXw-(Y^TX)^T-(X^TY)]\<br>    &amp;= \frac{1}{2}[2X^TXw-2(X^TY)]\<br>    &amp;= X^TXw-X^TY<br>\end{aligned}<br>$$<br>令导数为 0 ，$\frac{\partial J(w)}{\partial w}$ = 0，解得：<br>$$<br>w=(X^TX)^{-1}X^TY<br>$$<br>PS：但是不是所有矩阵都有可逆矩阵，最小二乘法并不一定能求解所有 <em><strong>w</strong></em> 参数，因此引入梯度下降法</p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><h3 id="梯度下降法参数更新计算公式"><a href="#梯度下降法参数更新计算公式" class="headerlink" title="梯度下降法参数更新计算公式"></a>梯度下降法参数更新计算公式</h3><p>$$<br>w = w-a\frac{\partial J(w)}{\partial w}<br>$$</p><h3 id="梯度下降法求解步骤"><a href="#梯度下降法求解步骤" class="headerlink" title="梯度下降法求解步骤"></a>梯度下降法求解步骤</h3><ol><li>设 a 学习率</li><li>求解梯度</li><li>梯度参数更新$w = w-a\frac{\partial J(w)}{\partial w}$</li></ol><h3 id="案例理解"><a href="#案例理解" class="headerlink" title="案例理解"></a>案例理解</h3><p>现在假设有一个损失函数为：$J(w)=4w^2$</p><p>首先需要随机初始化 <em><strong>w</strong></em> ，假设 <em><strong>w</strong></em> = 4，同时设定学习率为 0.1。损失函数的导数如下式所示：<br>$$<br>w_0=4,a=0.1,\frac{\partial J(w)}{\partial w}=8w<br>$$<br>第一次 <em><strong>w</strong></em> 更新的过程计算如下：<br>$$<br>\begin{aligned}<br>w_1 &amp;= w_0-0.1\times\frac{\partial J(w)}{\partial w}\<br>    &amp;= 4-0.1\times8\times4\<br>    &amp;= 0.8<br>\end{aligned}<br>$$<br>后续 <em><strong>w</strong></em> 更新的过程如下：<br>$$<br>\begin{aligned}<br>w_2 &amp;= 0.8-0.1\times8\times0.8=0.16\<br>w_3 &amp;= 0.16-0.1\times8\times0.16=0.032\<br>w_4 &amp;= 0.032-0.1\times8\times0.032=0.0064\<br>\end{aligned}<br>$$<br>假设此时设置学习效率为 0.5：<br>$$<br>\begin{aligned}<br>w_0 &amp;= 4\<br>w_1 &amp;= 4-0.5\times8\times4=-12\<br>w_2 &amp;= -12-0.5\times8\times(-12)=32\<br>w_3 &amp;= 32-0.5\times8\times32=96\<br>\end{aligned}<br>$$</p><h2 id="逻辑回归模型"><a href="#逻辑回归模型" class="headerlink" title="逻辑回归模型"></a>逻辑回归模型</h2><h3 id="回归与分类的区别"><a href="#回归与分类的区别" class="headerlink" title="回归与分类的区别"></a>回归与分类的区别</h3><p>在机器学习有监督学习中大致可以分为两大任务，一种是回归任务，一种是分类任务，官方说法：输入变量与输出变量均为连续变量的预测问题是回归问题，输出变量为有限个离散变量的预测问题为分类问题。</p><h4 id="回归："><a href="#回归：" class="headerlink" title="回归："></a>回归：</h4><p>通俗举例，一个人每日的运动时间、睡眠时间、工作时间、饮食等一些特征来预测一个人的体重，一个人的体重的值可以有无限个值。所以预测的结果是无限的、不确定的连续数值。这样的机器学习任务就是回归任务。</p><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>如果利用一个人每日的运动时间、睡眠时间、工作时间、饮食等一些特征来判断这个人的身体状况是否健康，那么最终的判断的结果就只有两种，健康和不健康。这样的输出结果为离散值，预测的结果也是一个有限的数值来代表种类。这样的机器学习任务就是分类任务。</p><h3 id="逻辑回归算法原理"><a href="#逻辑回归算法原理" class="headerlink" title="逻辑回归算法原理"></a>逻辑回归算法原理</h3><p>sigmoid 函数的定义如下：<br>$$<br>g(z)=\frac {1}{1+e^{-z}}<br>$$<br>在 sigmoid 函数中，<em><strong>e</strong></em> 为欧拉常数，自变量 <em><strong>z</strong></em> 可以取任意实数，函数的值域为 [0,1]，这就相当于将输入的自变量值映射到 0-1 之间。下面将函数的自变量转化为利用输入的数据特征来表示，以此利用 sigmoid 函数对其进行映射。<br>$$<br>z=w_0x_0+w_1x_1+w_nx_n+b\<br>z=W^TX+b<br>$$<br>此时自变量就转变成输入的数据特征了，特征利用向量 <em><strong>X</strong></em> 表示。同时特征还有对应的权重参数向量 <em><strong>W</strong></em> 来表示这个数据特征的重要程度，同时还有偏置参数 b。因此，逻辑回归模型可以用如下的公式来表达:<br>$$<br>g(X)=\frac{1}{1+e^{-W^TX+b}}<br>$$<br> 因此对于一个二分类问题，此时正例和反例的函数表达式就如下所示：</p><p>预测结果为正例的表达式：<br>$$<br>p(y=1|X)=\frac{1}{1+e^{-W^TX+b}}<br>$$<br>预测结果为反例的表达式：<br>$$<br>p(y=0|X)=\frac{e^{-W^TX+b}}{1+e^{-W^TX+b}}=1-p(y=1|X)<br>$$<br>在函数的计算推导过程中，考虑到正反两例情况，因此结合上述两个例子合并起来得到如下公式：<br>$$<br>p(y|X)=p(y|X)^y[1-p(y|X)]^{1-y}<br>$$</p><h3 id="逻辑回归——参数更新"><a href="#逻辑回归——参数更新" class="headerlink" title="逻辑回归——参数更新"></a>逻辑回归——参数更新</h3><p>损失函数公式为：<br>$$<br>J(w,b)=-\frac {1}{m}\sum_{i=1}^{m}[y_i\log \sigma(w^Tx_i+b)+(1-y_i)\log (1-\sigma(w^Tx_i+b))]<br>$$</p><p>参数 <em><strong>w</strong></em> 的偏导数的计算步骤如下所示：<br>$$<br>\begin{aligned}<br>\frac{\partial J(w,b)}{\partial w}<br>    &amp;=-\frac{1}{m}\sum_{i=1}^{m}\frac {\partial [y_i\log \sigma(w^Tx_i+b)+(1-y_i) \log(1-\sigma(w^Tx_i+b))]}{\partial w}\<br>    &amp;=-\frac{1}{m} \sum_{i=1}^{m}y_i\frac{\sigma (w^Tx_i+b)[1-\sigma(w^Tx_i+b)]}{\sigma(w^Tx_i+b)}x_i+(1-y_i)\frac {-\sigma (w^Tx_i+b)[1-\sigma(w^Tx_i+b)]}{1-\sigma (w^Tx_i+b)}x_i\<br>    &amp;=-\frac{1}{m}\sum_{i=1}^{m}y_ix_i-\sigma(w^Tx_i+b)x_i\<br>    &amp;=\frac {1}{m}\sum_{i=1}^{m}(\sigma(w^Tx_i+b)-y_i)x_i)<br>\end{aligned}<br>$$<br>参数 <em><strong>b</strong></em> 的偏导数计算步骤如下所示：<br>$$<br>\begin{aligned}<br>\frac{\partial J(w,b)}{\partial b}<br>    &amp;=-\frac{1}{m}\sum_{i=1}^{m}\frac {\partial [y_i\log \sigma(w^Tx_i+b)+(1-y_i) \log(1-\sigma(w^Tx_i+b))]}{\partial b}\<br>    &amp;=-\frac{1}{m} \sum_{i=1}^{m}y_i\frac{\sigma (w^Tx_i+b)[1-\sigma(w^Tx_i+b)]}{\sigma(w^Tx_i+b)}+(1-y_i)\frac {-\sigma (w^Tx_i+b)[1-\sigma(w^Tx_i+b)]}{1-\sigma (w^Tx_i+b)}\<br>    &amp;=-\frac{1}{m}\sum^{m}<em>{i=1}y_i[1-\sigma(w^Tx_i+b)]+(y_i-1)\sigma(w^Tx_i+b)\<br>    &amp;=\frac{1}{m}\sum^{m}</em>{i=1}\sigma(w^Tx_i+b)-y_i<br>\end{aligned}<br>$$</p><h2 id="分类和回归模型评价指标"><a href="#分类和回归模型评价指标" class="headerlink" title="分类和回归模型评价指标"></a>分类和回归模型评价指标</h2><h3 id="分类模型的评价指标"><a href="#分类模型的评价指标" class="headerlink" title="分类模型的评价指标"></a>分类模型的评价指标</h3><p>官方的评价指标定义稍显抽象，在此引入一个案例帮助自己更好的理解各个评价指标的具体含义。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>现在有一个深度学习的模型来检测病人是否有肿瘤，显然这是一个二分类的任务，只有两种结果，第一种结果是判定有肿瘤，第二种是判定没有肿瘤。假设现在有 100 个人，其中有 10 个人是患有肿瘤的，90 个人是健康的；现在这个深度学习模型对这 100个人进行判断，最后的判断结果为有 10 个人患有肿瘤，90 个人是健康的。对比真实的结果发现，10 个人被判断患有肿瘤的人中有5人是健康的，另外 5 个人是患有肿瘤的；而被判断为健康的 90 人中有 85 个人是健康的，另外 5 个人是患有肿瘤的。</p><p>在计算评价指标之前先定义一些参数，首先本案例的目标是判定一个人是否有肿瘤，那么有肿瘤就是正类，健康就是反类。定义参数如下：</p><ul><li>真实为正类，预测为正类，称为真正，用 TP 表示。本案例中一共有 10 个正类（患有肿瘤）其中有 5 个被预测出来了；因此本案例的 TP = 5。</li><li>真实为负类，预测为负类，称为真负，用 TN 表示。本案例中一共有 90 个负类（健康）其中有 85 个被预测出来了；因此本案例的 TN = 85。</li><li>真实为负类，预测为正类，称为假正（误报），用 FP 表示。本案例中一共有 90 个负类（健康），其中有 5 个被预测为正类（患有肿瘤）；因此本案例的 FP = 5。</li><li>真实为正类，预测为负类，称为假负(漏报)，用 FN 表示。本案例中一共有 10 个正类（患有肿瘤），其中有 5 个被预测为负类（健康）；因此本案例的 FN = 5。</li></ul><h4 id="准确率："><a href="#准确率：" class="headerlink" title="准确率："></a>准确率：</h4><p>通俗的说就是有多少判断对了，这个评价指标是将正类和负类是否都预测对包含在内，因此准确率的计算公式如下所示：<br>$$<br>ACC=\frac {TP+TN}{TP+TN+FP+FN}<br>$$<br>利用该公式计算模型的准确率为：$ACC=\frac{5+85}{5+85+5+5}=90%$</p><p>从最后的准确率来看，模型的效果貌似是不错的，但是在案例中我们看到有 10 个人患有肿瘤，这个模型只预测出了 5 个，如果我们偏信这个模型的话，那将会有 5 个人漏报，产生的结果将十分严重。导致这样的结果的原因是因是样本不均衡，因为正类和负类数量相差太大。假设在这样一个不均衡的样本中，直接认定所有的样本都是正类，那么准确率也能达到 90%。因此此时准确率就不能很好的作为模型的评价指标了。</p><h4 id="精确率："><a href="#精确率：" class="headerlink" title="精确率："></a>精确率：</h4><p>精确率又叫查准率，精确率告诉我们在预测出来的正类样本中，真正为正类的比例是多少，精确率的计算公式为：<br>$$<br>P=\frac{TP}{TP+FP}<br>$$<br>利用该公式计算模型的精确率为：$P=\frac{5}{5+5}=50%$，由此可见该模型对患有癌症的识别并不准确。</p><h4 id="召回率："><a href="#召回率：" class="headerlink" title="召回率："></a>召回率：</h4><p>召回率又叫查全率，召回率告诉我们所有的正类样本中，有多少被识别出来了，具体计算公式如下：<br>$$<br>Recall=\frac{TP}{TP+FN}<br>$$<br>利用该公式计算模型的召回率为：$Recall=\frac{5}{5+5}=50%$</p><h4 id="F1-值："><a href="#F1-值：" class="headerlink" title="F1 值："></a>F<del>1</del> 值：</h4><p>F<del>1</del> 值是精确率和召回率的调和均值，具体计算公式如下所示：<br>$$<br>F_1=\frac {2TP}{2TP+FP+FN}<br>$$<br>精确率和准确率都高的情况下，F<del>1</del>的值也会高。</p><h3 id="回归模型的评价指标"><a href="#回归模型的评价指标" class="headerlink" title="回归模型的评价指标"></a>回归模型的评价指标</h3><p>和分类模型不同的是，回归模型的输出是一个连续的值，或者可以说是不确定的值。那么用精确度和准确度等评价指标就不那么合理了。从回归模型的任务性质来说，我们希望得到的回归预测值尽可能的接近于真实值，也就是预测值和真实值之间的误差尽可能小，因此我们可以用如下的评价指标。</p><h4 id="平均绝对误差-MAE"><a href="#平均绝对误差-MAE" class="headerlink" title="平均绝对误差(MAE)"></a>平均绝对误差(MAE)</h4><p>$$<br>MAE=\frac{1}{n}\sum_{i=1}^{n}\lvert(y_i-\hat y_i)\rvert<br>$$</p><p>其中 y<del>i</del> 为真实值，$\hat y_i$ 为回归预测值，n 为回归的数据个数。</p><h4 id="均方误差-MSE"><a href="#均方误差-MSE" class="headerlink" title="均方误差(MSE)"></a>均方误差(MSE)</h4><p>$$<br>MSE=\frac{1}{n}\sum^{n}_{i=1}(y_i-\hat y_i)^2<br>$$</p><p>其中 y<del>i</del> 为真实值，$\hat y_i$ 为回归预测值，n 为回归的数据个数。该公式也用于回归的损失函数，并且可导（MAE绝对值不是处处可导），即最小化均方误差。值越小，性能越好。</p><h4 id="均方根误差-RMSE"><a href="#均方根误差-RMSE" class="headerlink" title="均方根误差(RMSE)"></a>均方根误差(RMSE)</h4><p>$$<br>RMSE=\sqrt{\frac{1}{n}\sum^{n}_{i=1}(y_i-\hat y_i)^2}<br>$$</p><p>其中 y<del>i</del> 为真实值，$\hat y_i$ 为回归预测值，n 为回归的数据个数。实质与均方根误差 MSE 相同，主要用于降低均方误差的数量级，防止均方误差 MSE 看起来很大。</p><h4 id="MAPE"><a href="#MAPE" class="headerlink" title="MAPE"></a>MAPE</h4><p>$$<br>MAPE=\frac{1}{n}\sum_{i=1}^{n}\lvert \frac{y_i-\hat y_i}{y_i}\rvert\times100%<br>$$</p><p>其中 y<del>i</del> 为真实值，$\hat y_i$ 为回归预测值，n 为回归的数据个数。注意由于这里用了 y<del>i</del> 作为分母，所以当测量真实值有数据为 0 时，即存在分母为 0 的情况，该指标公式就不可用了，值越小越好。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 线性回归 </tag>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记</title>
      <link href="/2021/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-概述"><a href="#计算机网络-概述" class="headerlink" title="计算机网络-概述"></a>计算机网络-概述</h1><h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p>网络把主机连接起来，而互联网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</p><p>互连网 (internet) ≠ 互联网 (Internet)</p><h2 id="互联网基础结构发展的三个阶段"><a href="#互联网基础结构发展的三个阶段" class="headerlink" title="互联网基础结构发展的三个阶段"></a>互联网基础结构发展的三个阶段</h2><ol><li>1969 - 1990 从单个网络 ARPANET 向互联网发展</li><li>1985 - 1993 建成了三级结构的互联网</li><li>1993 - 现在 全球范围的多层次 ISP 结构的互联网</li></ol><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p><h3 id="多层次-ISP-结构"><a href="#多层次-ISP-结构" class="headerlink" title="多层次 ISP 结构"></a>多层次 ISP 结构</h3><p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小和所拥有的 IP 地址数目分为主干 ISP 、地区 ISP 和本地 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p><p><img src="https://i.loli.net/2021/09/29/rztmHYjoVKfLWle.png"></p><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><p>从互联网的工作方式上看，可以划分为两大块：</p><ul><li><p><strong>边缘部分：</strong>由所有连接在互联网上的 <strong>主机</strong> 组成，有用户直接使用，用来进行通信（传送数据、音频或视频）和资源共享。</p></li><li><p><strong>核心部分：</strong>由大量 <strong>网络</strong> 和连接这些网络的 <strong>路由器</strong> 组成，为边缘部分提供服务（提供连通性和交换）。</p><p><img src="https://i.loli.net/2021/09/29/l9R8j2isQ7ybNhP.png"></p></li></ul><h2 id="主机（端系统）之间的通讯方式"><a href="#主机（端系统）之间的通讯方式" class="headerlink" title="主机（端系统）之间的通讯方式"></a>主机（端系统）之间的通讯方式</h2><ul><li><p>客户 / 服务 (C / S) ：客户是服务的请求方，服务器是服务的提供方。</p><ul><li>客户 / 服务器方式所描述的是进程之间服务和被服务的关系。</li><li>客户与服务器的通信关系建立后，通信可以是 <code>双向的</code> ，客户和服务器都可以发送和接收数据。</li></ul><p><img src="https://i.loli.net/2021/09/29/1HBUyxOIACJicbD.png"></p></li><li><p>对等连接（P2P）：两台主机在通信时 <strong>不区分</strong> 服务请求方和服务提供方。</p><ul><li>对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机 <strong>既是客户又是服务器。</strong></li></ul><p><img src="https://i.loli.net/2021/09/29/VL9DyIqo1irYgGe.png"></p></li></ul><h2 id="典型交换技术"><a href="#典型交换技术" class="headerlink" title="典型交换技术"></a>典型交换技术</h2><ul><li><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3></li></ul><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在 <strong>整个通信过程中始终占用该链路。</strong>由于通信的过程中不可能一直在使用传输线路，因此电路交换对于 <strong>线路的利用率很低</strong>，往往不到10%。</p><ul><li><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3></li></ul><p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p><ul><li><p>互联网采用分组交换技术。分组是在互联网中传送的 <strong>数据单元</strong>。</p></li><li><p>发送端 <strong>依次</strong> 把各分组发送到接收端。</p></li></ul><p><img src="https://i.loli.net/2021/09/29/FvlxXLgRtkOPcEj.png"></p><h4 id="分组在互联网中的转发"><a href="#分组在互联网中的转发" class="headerlink" title="分组在互联网中的转发"></a>分组在互联网中的转发</h4><ul><li>根据 <strong>首部</strong> 中包含的目的地址、源地址等重要控制信息进行转发。</li><li>每一个分组在互联网中 <strong>独立选择</strong> 传输路径。</li><li>位于网络核心部分的 <strong>路由器负责转发分组</strong>，即进行分组交换。</li><li>路由器要创建和动态维护 <strong>转发表</strong>。</li></ul><p><img src="https://i.loli.net/2021/09/29/EgTOuCkas6z3o5A.png"></p><table><thead><tr><th align="center">优点</th><th align="center">所采用的手段</th></tr></thead><tbody><tr><td align="center">高效</td><td align="center">在分组传输的过程中 <strong>动态分配</strong> 传输带宽，对通信链路是 <strong>逐段</strong> 占用。</td></tr><tr><td align="center">灵活</td><td align="center">为每一个分组 <strong>独立</strong> 地选择最合适的转发路由。</td></tr><tr><td align="center">迅速</td><td align="center">以分组作为传送单位，可以 <strong>不先建立连接</strong> 就能向其他主机发送分组。</td></tr><tr><td align="center">可靠</td><td align="center">保证可靠性的网络协议；分布式多路由的分组交换网，是网络有很好地生存性。</td></tr></tbody></table><h4 id="存储转发"><a href="#存储转发" class="headerlink" title="存储转发"></a>存储转发</h4><p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p><ul><li><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3></li></ul><p>报文交换是基于存储转发原理的。但是报文交换的时延较长，从几分钟到几小时不等，现在已经很少有人使用了。</p><h3 id="三种交换方式的比较"><a href="#三种交换方式的比较" class="headerlink" title="三种交换方式的比较"></a>三种交换方式的比较</h3><ul><li>若要连续传送 <strong>大量</strong> 的数据，且其传送时间 <strong>远大于</strong> 连接建立时间，则 <strong>电路交换</strong> 的传输速率较快。</li><li><strong>报文交换</strong> 和 <strong>分组交换</strong> 不需要预先分配传输带宽，在传送 <strong>突发数据</strong> 时可提高整个网络的信道利用率。</li><li>由于一个分组的长度往往 <strong>远小于</strong> 整个报文的长度，因此 <strong>分组交换</strong> 比报文交换的时延小，同时也具有更好的灵活性。</li></ul><p><img src="https://i.loli.net/2021/09/29/OYEIplyPeBGiw9n.png"></p><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><p><strong>性能指标：</strong>从不同方面度量计算机网络的性能。</p><h3 id="1、速率"><a href="#1、速率" class="headerlink" title="1、速率"></a>1、速率</h3><ul><li><p>最重要的一个性能指标。</p></li><li><p>指的是 <strong>数据的传送速率</strong>，也称为 <strong>数据率</strong>（data rate）或 <strong>比特率</strong>（bit rate）。</p></li><li><p>单位：bit/s，或 kbit/s、Mbit/s、GBit/s 等。</p><p>例如 4 × 10<sup>10</sup> bit/s 的数据率就记为 40 Gbit/s。</p></li><li><p>速率往往是指 <strong>额定速率</strong> 或 <strong>标称速率</strong>，而非实际运行速率。</p></li></ul><p>$$<br>千=K=2^{10}=1024,兆=M=2^{20}=1024K,吉=G=2^{30}=1024M,1字节(Byte)=8比特(bit)<br>$$</p><h3 id="2、带宽"><a href="#2、带宽" class="headerlink" title="2、带宽"></a>2、带宽</h3><ul><li>频域：<ul><li>某个型号具有的频带宽度</li><li>单位：赫（或千赫、兆赫、吉赫等）。</li><li>某信道允许通过的信号频带范围称为该信道的带宽（或通频带）。</li></ul></li><li>时域：<ul><li>网络中某通道传送数据的能力，表示在单位时间内网络中的某信道所能通过的“最高数据率”、</li><li>单位：数据率的单位 bit/s。</li></ul></li></ul><p>二者的本质相同，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</p><h3 id="3、吞吐量"><a href="#3、吞吐量" class="headerlink" title="3、吞吐量"></a>3、吞吐量</h3><ul><li>单位时间内通过某个网络（或信道、接口）的实际数据量。</li><li>受网络带宽或网络的额定时速率的限制。<ul><li>额定速率是绝对上限值。</li><li>可能会远小于额定速率，甚至下降到零！</li></ul></li><li>有时可用每秒传送的字节数或帧数来表示。、</li></ul><h3 id="4、时延（重要！！）"><a href="#4、时延（重要！！）" class="headerlink" title="4、时延（重要！！）"></a>4、时延（重要！！）</h3><ul><li>指数据（一个报文或分组，甚至比特）从网络（或链路）的 <strong>一端传送到另一端所需的时间</strong>。</li><li>有时也称为延迟或迟延。</li><li>组成：发送时延、传播时延、处理时延、排队时延</li></ul><ol><li><p><strong>发送时延</strong></p><ul><li><p>也称为传输时延。</p></li><li><p>是主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的 <strong>第一个比特</strong> 算起，到该帧的 <strong>最后一个比特</strong> 发送完毕所需的时间。<br>$$<br>发送时延=\frac{数据帧长度(bit)}{发送速率(bits/s)}<br>$$</p></li></ul></li><li><p><strong>传播时延</strong></p><ul><li><p>是 <strong>电磁波</strong> 在信道中传播一定的举例需要花费的时间。<br>$$<br>传播时延=\frac{信道长度(米)}{信号在信道上的传播速率(米/秒)}<br>$$</p></li><li><p>电磁波传播速率：</p><ul><li>自由空间的传播速率是光速 = 3.0 × 10<sup>5</sup> km/s</li><li>在铜线电缆中的传播速率约 = 2.3 × 10<sup>5</sup> km/s</li><li>在光纤中的传播速度约 = 2.0 × 10<sup>5</sup> km/s</li></ul></li></ul><p><strong>注意：</strong> 发送时延与传播时延有本质上的不同。</p><ul><li><strong>发送时延</strong> 发生在机器内部的发送器中，与传输信道的长度（或信号传送的距离）没有任何关系。</li><li><strong>传播时延</strong> 则发生在机器外部的传输信道媒体上，而与信号的发送速率无关。信号发送的距离越远，传播时延就越大。</li></ul></li><li><p><strong>处理时延</strong></p><ul><li>主机或路由器在收到分组时，为 <strong>处理</strong> 分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。</li></ul></li><li><p><strong>排队时延</strong></p><ul><li>分组在路由器输入输出队列中 <strong>排队等待</strong> 处理和转发所经历的时延。</li><li>排队时延的长短往往取决于网络中当时的通信量。当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延为无穷大。</li></ul></li></ol><p>   $$<br>   总时延=发送时延+传播时延+处理时延+排队时延<br>   $$</p><ul><li>一般来说，小时延的网络要 <strong>优于</strong> 大时延的网络。</li><li>在某些情况下，一个低速率、小时延的网络很可能要 <strong>优于</strong> 一个高速率大大时延的网络。</li></ul><p><img src="https://i.loli.net/2021/09/30/a2bLEAUBvsmcgRd.png"></p><ol start="5"><li><strong>时延带宽积</strong><ul><li>链路的时延带宽积又称为以比特为单位的 <strong>链路长度</strong>。</li><li>管道中的比特数表示从发送端发出 <strong>但尚未</strong> 到达接收端的比特数。</li></ul></li></ol><p>$$<br>时延带宽积=传播时延×带宽<br>$$</p><ol start="6"><li><p><strong>往返时间 RTT (Round-Trip Time)</strong></p><ul><li><p>表示从发送方<strong>发送完数据</strong>，到发送方 <strong>接收到来自接收方的确认</strong> 总共经历的时间。</p><p><img src="https://i.loli.net/2021/09/30/5pGwQzAPNklSqIy.png"></p></li><li><p>在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。</p></li><li><p>当使用卫星通信时，往返时间 RTT 相对较长，此时，RTT 是很重要的一个性能指标。</p></li></ul></li></ol><ol start="7"><li><strong>利用率</strong><ul><li>信道利用率：某信道有百分之几的时间是被利用的（即有数据通过）。</li><li>网络利用率：全网络的信道利用率的加权平均值。</li><li>根据排队论，当某信道的利用率增大时，时延会迅速增加。</li></ul></li></ol><p>$$<br>D=\frac{D_0}{1-U}<br>$$</p><p>其中：D<sub>0</sub>：网络空闲时的时延。；D：网络在当前的时延；U：网络当前的利用率，数值在 0 到 1 之间。</p><p><img src="https://i.loli.net/2021/09/30/1ikK4xEzZSvjpUN.png" alt="网络利用率和时延的关系"></p><center>网络利用率和时延的关系</center><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><ul><li><strong>网络协议</strong>（network protocol），简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。</li><li>三个组成要素：<ul><li>语法：数据与控制信息的结构或格式。</li><li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应。</li><li>同步：事件实现顺序的详细说明。</li></ul></li></ul><p><img src="https://i.loli.net/2021/09/30/tLRvMpDQmUdlG7A.png"></p><ol><li><strong>五层协议</strong><ul><li><strong>应用层</strong>：为特定应用程序提供数据传输服务，例如 HTTP、DNS等协议。数据单位为报文。</li><li><strong>传输层</strong>：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠地数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性，UDP 主要提供及时性服务。</li><li><strong>网络层</strong>：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong>：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务、数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong>：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul></li><li><strong>OSI</strong><ul><li>OSI 参考模型把对等层次之间传送的数据单位称为该层的 <strong>协议数据单元 PDU</strong> （Protocol Data Unit）。</li><li>任何两个同样的层次吧 PDU （即数据单元加上控制信息）通过水平虚线直接传递给对方。这就是所谓的 <strong>”对等层“</strong> 之间的通信。</li><li>其中表示层和会话层用途如下：<ul><li>表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li>会话层：建立及管理会话。</li></ul></li><li>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</li></ul></li><li><strong>TCP/IP</strong><ul><li>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</li><li>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</li></ul></li></ol><p><img src="https://i.loli.net/2021/10/01/A72xtQg63arzYDc.png"></p><ol start="4"><li><strong>数据在各层之间的传递过程</strong><ul><li>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</li><li>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构MOOC 03-树2 List Leaves</title>
      <link href="/2021/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%2003-%E6%A0%912%20List%20Leaves/"/>
      <url>/2021/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%2003-%E6%A0%912%20List%20Leaves/</url>
      
        <content type="html"><![CDATA[<h1 id="03-树-2-List-Leaves"><a href="#03-树-2-List-Leaves" class="headerlink" title="03-树 2 List Leaves"></a><strong>03-树 2 List Leaves</strong></h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>Given a tree, you are supposed to list all the leaves in the order of top down, and left to right.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to <em>N</em>−1. Then <em>N</em> lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a “-“ will be put at the position. Any pair of children are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line all the leaves’ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">1 -</span><br><span class="line">- -</span><br><span class="line">0 -</span><br><span class="line">2 7</span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line">5 -</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 1 5</span><br></pre></td></tr></table></figure><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><p>题目要求通过输入节点数以及每个节点的左儿子和右儿子，从上到下打印出叶节点。解题的关键是通过层序遍历找到叶子结点去输出。</p><p>根据题意搭建程序框架：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">输入建立二叉树</span><br><span class="line">寻找叶子结点并输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的框架较为简单，只需要两个函数就可以完成题目要求，接下来分析两个函数的实现方法。</p><p>① 输入建立二叉树函数</p><p>根据题目的输入要求，我们可以使用静态链表即结构体数组的方式来存储二叉树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;T[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>输入的第几行就是代表该节点的值为几。例如样例输入中第 0 行的 1 -代表值为 0 的节点左孩子的值为 1，即指向第 1 行，右孩子为空（-1），建树应该是这样：<img src="https://img-blog.csdnimg.cn/img_convert/f949f953147ae97d747664d658484ecb.png" alt="img"></p><p>二叉树根结点的位置不一定位于输入的第一行，因此在建二叉树的过程中，找出所建二叉树的根结点很关键。我们在建树的过程中寻找根结点的位置就可以通过遍历结构体数组中左右子树指向的下标，缺少的那个下标即是根结点所在下标。遍历的方法可以是创建一个 <code>check[]</code> 数组，初始化所有位置数值都为 0，然后在所有输入的左右子树的下标对应的 <code>check[]</code> 数值记为 1，最后遍历 <code>check[]</code> 数组找到数值为 0 的下标即是根结点所在位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据建二叉树的函数，返回根结点的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buildTree</span><span class="params">(Tree t[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">-1</span>;    <span class="comment">// s 根结点位置下标</span></span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">char</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> check[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i].data = i;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i].left = l - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">// 将字符转化为整型</span></span><br><span class="line">            check[t[i].left] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t[i].left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i].right = r - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">// 将字符转化为整型</span></span><br><span class="line">            check[t[i].right] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t[i].right = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!check[i])</span><br><span class="line">        &#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 层序遍历打印叶子节点的函数</p><p>要按照从上到下，从左到右的顺序找到并输出叶子结点就要应用到层序遍历二叉树的方法，层序遍历就要用到队列，我这里选择直接调用 STL 的 队列（queue），而没有自己手写队列操作。</p><p>首先建立一个保存叶子结点的数组，初始化每个叶子结点为 -1。首先建立队列，将二叉树根结点入队。接着在队列非空时，执行层序遍历操作，若队首元素的左右孩子全部为空，则说明其是叶子结点，将他存入 leaves 数组中；若其子树非空，按照先左后右的顺序入队，然后队首元素出队，直至队列为空，则遍历完毕。</p><p>最后控制输出，因为输出的叶子结点之间都有空格，可以看做除了第一个元素外，都是输出“空格 + 叶子结点”，只需要设置标记将第一个输出的元素找到不输出空格就好。然后遍历输出 leaves 数组，即可得到结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历打印叶子节点的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintLeaves</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leaves[<span class="number">10</span>];  <span class="comment">// 存储叶结点的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        leaves[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">bool</span> isFirst = <span class="number">1</span>;   <span class="comment">// 控制输出</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;  <span class="comment">// 创建队列</span></span><br><span class="line">    Q.<span class="built_in">push</span>(r);   <span class="comment">// 将根结点压入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())   <span class="comment">// 当队列非空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = Q.<span class="built_in">front</span>();  <span class="comment">// 队首元素</span></span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (T[i].left == <span class="number">-1</span> &amp;&amp; T[i].right == <span class="number">-1</span>)</span><br><span class="line">            leaves[k++] = T[i].data;</span><br><span class="line">        <span class="keyword">if</span> (T[i].left != <span class="number">-1</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(T[i].left);</span><br><span class="line">        <span class="keyword">if</span> (T[i].right != <span class="number">-1</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(T[i].right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (leaves[j] != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isFirst)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; leaves[j++];</span><br><span class="line">        isFirst = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> <span class="title">Tree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;T[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> N;  <span class="comment">// 结点数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buildTree</span><span class="params">(Tree t[])</span></span>;  <span class="comment">// 读取数据建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintLeaves</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> n)</span></span>;   <span class="comment">// 判断两个二叉树是否同构的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    r = <span class="built_in">buildTree</span>(T);</span><br><span class="line">    <span class="built_in">PrintLeaves</span>(r,N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据建二叉树的函数，返回根结点的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buildTree</span><span class="params">(Tree t[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">-1</span>;    <span class="comment">// s 根结点位置下标</span></span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">char</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> check[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i].data = i;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i].left = l - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">// 将字符转化为整型</span></span><br><span class="line">            check[t[i].left] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t[i].left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i].right = r - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">// 将字符转化为整型</span></span><br><span class="line">            check[t[i].right] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t[i].right = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!check[i])</span><br><span class="line">        &#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历打印叶子节点的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintLeaves</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leaves[<span class="number">10</span>];  <span class="comment">// 存储叶结点的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        leaves[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">bool</span> isFirst = <span class="number">1</span>;   <span class="comment">// 控制输出</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;  <span class="comment">// 创建队列</span></span><br><span class="line">    Q.<span class="built_in">push</span>(r);   <span class="comment">// 将根结点压入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())   <span class="comment">// 当队列非空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = Q.<span class="built_in">front</span>();  <span class="comment">// 队首元素</span></span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (T[i].left == <span class="number">-1</span> &amp;&amp; T[i].right == <span class="number">-1</span>)</span><br><span class="line">            leaves[k++] = T[i].data;</span><br><span class="line">        <span class="keyword">if</span> (T[i].left != <span class="number">-1</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(T[i].left);</span><br><span class="line">        <span class="keyword">if</span> (T[i].right != <span class="number">-1</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(T[i].right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (leaves[j] != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isFirst)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; leaves[j++];</span><br><span class="line">        isFirst = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构MOOC 03-树1 树的同构</title>
      <link href="/2021/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%2003-%E6%A0%911%20%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/"/>
      <url>/2021/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%2003-%E6%A0%911%20%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="03-树-1-树的同构"><a href="#03-树-1-树的同构" class="headerlink" title="03-树 1 树的同构"></a><strong>03-树 1 树的同构</strong></h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定两棵树 T1 和 T2。如果 T1 可以通过若干次左右孩子互换就变成 T2，则我们称两棵树是“同构”的。例如图 1 给出的两棵树就是同构的，因为我们把其中一棵树的结点 A、B、G 的左右孩子互换后，就得到另外一棵树。而图 2 就不是同构的。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b064212154a4c309d741f770c240e271.png" alt="fig1.jpg"></p><center> 图 1</center><p><img src="https://img-blog.csdnimg.cn/img_convert/d6062c798e72d4fa4e05212a61033c0b.png" alt="img"></p><center> 图 2</center><p>现给定两棵树，请你判断它们是否是同构的。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入给出 2 棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数<em>N</em> (≤10)，即该树的结点数（此时假设结点从 0 到<em>N</em>−1 编号）；随后<em>N</em>行，第<em>i</em>行对应编号第<em>i</em>个结点，给出该结点中存储的 1 个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p><h3 id="输入样例-1（对应图-1）："><a href="#输入样例-1（对应图-1）：" class="headerlink" title="输入样例 1（对应图 1）："></a>输入样例 1（对应图 1）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">A 1 2</span><br><span class="line">B 3 4</span><br><span class="line">C 5 -</span><br><span class="line">D - -</span><br><span class="line">E 6 -</span><br><span class="line">G 7 -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line">8</span><br><span class="line">G - 4</span><br><span class="line">B 7 6</span><br><span class="line">F - -</span><br><span class="line">A 5 1</span><br><span class="line">H - -</span><br><span class="line">C 0 -</span><br><span class="line">D - -</span><br><span class="line">E 2 -</span><br></pre></td></tr></table></figure><h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例 1:"></a>输出样例 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="输入样例-2（对应图-2）："><a href="#输入样例-2（对应图-2）：" class="headerlink" title="输入样例 2（对应图 2）："></a>输入样例 2（对应图 2）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">B 5 7</span><br><span class="line">F - -</span><br><span class="line">A 0 3</span><br><span class="line">C 6 -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G 4 -</span><br><span class="line">E 1 -</span><br><span class="line">8</span><br><span class="line">D 6 -</span><br><span class="line">B 5 -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C 0 2</span><br><span class="line">G - 3</span><br><span class="line">F - -</span><br><span class="line">A 1 4</span><br></pre></td></tr></table></figure><h3 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例 2:"></a>输出样例 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>题目要求判断按格式输入的两个二叉树是否同构，其实就是判断每个结点的左右子树是否相同（左右相同或者左左和右右分别相同），根据题目要求搭建程序框架：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">建二叉树 <span class="number">1</span></span><br><span class="line">建二叉树 <span class="number">2</span></span><br><span class="line">判断是否同构并输出</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题的程序框架较为简单，根据框架需要设计 <code>读数据建二叉树</code>、<code>二叉树同构判断</code>这两个函数。</p><p>① 读数据建二叉树的函数</p><p>根据题目的输入要求，我们可以使用静态链表即结构体数组的方式来存储二叉树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;T1[<span class="number">10</span>],T2[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>输入样例中可以看到，二叉树根结点的位置不一定位于输入的第一行，因此在建二叉树的过程中，找出所建二叉树的根结点很关键。以简单的四个结点的二叉树为例：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传 (img-7hGktDdw-1629624963590)(C:\Users\79485\AppData\Roaming\Typora\typora-user-images\image-20210820222827421.png)]</p><p>可以观察到，在结构体数组中四个结点分别占用了 0、1、2、3 四个下标位置，而结构体数组中左右子树指向的下标位置有 1、2、3，没有出现的 0 就是根结点所在的位置下标。因此，我们在建树的过程中寻找根结点的位置就可以通过遍历结构体数组中左右子树指向的下标，缺少的那个下标即是根结点所在下标。遍历的方法可以是创建一个 <code>check[]</code> 数组，初始化所有位置数值都为 0，然后在所有输入的左右子树的下标对应的 <code>check[]</code> 数值记为 1，最后遍历 <code>check[]</code> 数组找到数值为 0 的下标即是根结点所在位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据建二叉树的函数，返回根结点的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buildTree</span><span class="params">(Tree t[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, root = <span class="number">-1</span>;    <span class="comment">// 结点数量，根结点位置下标</span></span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">char</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> check[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; t[i].data &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i].left = l - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">// 将字符转化为整型</span></span><br><span class="line">            check[t[i].left] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t[i].left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i].right = r - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">// 将字符转化为整型</span></span><br><span class="line">            check[t[i].right] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t[i].right = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!check[i])</span><br><span class="line">        &#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 判断两二叉树是否同构的函数</p><p>判断二叉树是否同构就是判断两个二叉树的左右子树是否相同（可以是左左相同且右右相同，也可以是左右相同），使用递归判断就可以得出结论，但是要注意判断时要将各种情况考虑全面，包括子树为空时的各种情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断两二叉树是否同构的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">(<span class="keyword">int</span> t1, <span class="keyword">int</span> t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="number">-1</span> &amp;&amp; t2 == <span class="number">-1</span>)  <span class="comment">// 均为空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((t1 == <span class="number">-1</span> &amp;&amp; t2 != <span class="number">-1</span>) || (t1 != <span class="number">-1</span> &amp;&amp; t2 == <span class="number">-1</span>))    <span class="comment">// 两树中有一棵空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T1[t1].data != T2[t2].data)  <span class="comment">// 根结点数据不同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T1[t1].left == <span class="number">-1</span> &amp;&amp; T2[t2].left == <span class="number">-1</span>)    <span class="comment">// 左子树均为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Isomorphic</span>(T1[t1].right,T2[t2].right);</span><br><span class="line">    <span class="keyword">if</span> ((T1[t1].left != <span class="number">-1</span> &amp;&amp; T2[t2].left != <span class="number">-1</span>) &amp;&amp; (T1[T1[t1].left].data == T2[T2[t2].left].data) ) <span class="comment">// 无需交换左右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Isomorphic</span>(T1[t1].left,T2[t2].left) &amp;&amp; <span class="built_in">Isomorphic</span>(T1[t1].right,T2[t2].right);</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// 需要交换左右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Isomorphic</span>(T1[t1].left,T2[t2].right) &amp;&amp; <span class="built_in">Isomorphic</span>(T1[t1].right,T2[t2].left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> <span class="title">Tree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;T1[<span class="number">10</span>],T2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buildTree</span><span class="params">(Tree t[])</span></span>;  <span class="comment">// 读取数据建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">(<span class="keyword">int</span> t1, <span class="keyword">int</span> t2)</span></span>;   <span class="comment">// 判断两个二叉树是否同构的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1, t2;</span><br><span class="line">    t1 = <span class="built_in">buildTree</span>(T1);</span><br><span class="line">    t2 = <span class="built_in">buildTree</span>(T2);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Isomorphic</span>(t1,t2))</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据建二叉树的函数，返回根结点的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buildTree</span><span class="params">(Tree t[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, root = <span class="number">-1</span>;    <span class="comment">// 结点数量，根结点位置下标</span></span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">char</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> check[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; t[i].data &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i].left = l - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">// 将字符转化为整型</span></span><br><span class="line">            check[t[i].left] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t[i].left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i].right = r - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">// 将字符转化为整型</span></span><br><span class="line">            check[t[i].right] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t[i].right = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!check[i])</span><br><span class="line">        &#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两二叉树是否同构的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">(<span class="keyword">int</span> t1, <span class="keyword">int</span> t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="number">-1</span> &amp;&amp; t2 == <span class="number">-1</span>)  <span class="comment">// 均为空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((t1 == <span class="number">-1</span> &amp;&amp; t2 != <span class="number">-1</span>) || (t1 != <span class="number">-1</span> &amp;&amp; t2 == <span class="number">-1</span>))    <span class="comment">// 两树中有一棵空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T1[t1].data != T2[t2].data)  <span class="comment">// 根结点数据不同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T1[t1].left == <span class="number">-1</span> &amp;&amp; T2[t2].left == <span class="number">-1</span>)    <span class="comment">// 左子树均为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Isomorphic</span>(T1[t1].right,T2[t2].right);</span><br><span class="line">    <span class="keyword">if</span> ((T1[t1].left != <span class="number">-1</span> &amp;&amp; T2[t2].left != <span class="number">-1</span>) &amp;&amp; (T1[T1[t1].left].data == T2[T2[t2].left].data) ) <span class="comment">// 无需交换左右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Isomorphic</span>(T1[t1].left,T2[t2].left) &amp;&amp; <span class="built_in">Isomorphic</span>(T1[t1].right,T2[t2].right);</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// 需要交换左右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Isomorphic</span>(T1[t1].left,T2[t2].right) &amp;&amp; <span class="built_in">Isomorphic</span>(T1[t1].right,T2[t2].left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构MOOC 02-线性结构4 Pop Sequence</title>
      <link href="/2021/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%2002-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844%20Pop%20Sequence/"/>
      <url>/2021/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%2002-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844%20Pop%20Sequence/</url>
      
        <content type="html"><![CDATA[<h1 id="02-线性结构-4-Pop-Sequence"><a href="#02-线性结构-4-Pop-Sequence" class="headerlink" title="02-线性结构 4 Pop Sequence"></a><strong>02-线性结构 4 Pop Sequence</strong></h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h3><p>题目要求是按照 1, 2, 3, …, <em>N</em> 的顺序将数字压入栈中，但是会随机在某一时刻弹出，要求我们可以判断给出的出栈序列是否符合栈的入栈出栈规范，是否可能实现，是的话输出 “YES”，否输出“NO”。</p><p>解决方法主要就是模拟入栈和出栈的过程，在此过程中一旦发现违反栈 “先进后出” 的规则（栈顶元素大于当前弹出元素），或者栈溢出，就证明该种情况不成立；若将给出的测试序列全部走完未发现问题，则证明该种情况可能实现。</p><p>程序第一行要求输入三个数据：M（栈的最大容量）、N（每个输入序列的数据个数）、K（待测试的序列个数），接下来输入 K 行待检测序列，开始模拟入栈出栈操作。</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, k;    <span class="comment">// 堆栈最大容量，序列元素个数，待检测序列个数</span></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> stack[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">// 数组做堆栈，但是这里的数组大小不是堆栈的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;   <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;    <span class="comment">// 入栈元素</span></span><br><span class="line">    <span class="keyword">int</span> num;    <span class="comment">// 序列输入元素</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>;  <span class="comment">// 序列实现可能性的标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;   <span class="comment">// 重置标记</span></span><br><span class="line">        top = <span class="number">0</span>;   <span class="comment">// 清空堆栈后重新将 1 压入堆栈</span></span><br><span class="line">        stack[top] = <span class="number">1</span>;</span><br><span class="line">        cnt = <span class="number">1</span>;    <span class="comment">// 入栈元素重置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; num;</span><br><span class="line">            <span class="keyword">if</span>(stack[top] &gt; num)    <span class="comment">// 比栈顶元素小，必然不可能</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(stack[top] &lt; num) <span class="comment">// 比栈顶元素大</span></span><br><span class="line">            &#123;</span><br><span class="line">                top++;  <span class="comment">// 要继续压入数据</span></span><br><span class="line">                cnt++;</span><br><span class="line">                stack[top] = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top &gt; m<span class="number">-1</span>)   <span class="comment">// 栈溢出</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack[top] == num)   <span class="comment">// 等于栈顶元素，出栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top &lt; <span class="number">0</span>) <span class="comment">// 栈内元素全部出栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                top++;</span><br><span class="line">                cnt++;</span><br><span class="line">                stack[top] = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建操作流程</title>
      <link href="/2021/08/15/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
      <url>/2021/08/15/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客搭建操作流程"><a href="#个人博客搭建操作流程" class="headerlink" title="个人博客搭建操作流程"></a>个人博客搭建操作流程</h1><p>本系列将记录自己按照网络上的资源与教程第一次搭建自己的个人博客的全过程，将过程与自己搭建时的心得记录下来，为以后反看自己成长经历留下痕迹，也希望如果可以的话，帮助到其他想要尝试搭建自己个人博客的朋友。</p><p><strong>本文基于 Windows 10 系统，且默认已有 GitHub 账号以及安装下载好 git。</strong></p><p>若还没有 GitHub 账号，可参考这篇博文注册 <a href="https://blog.csdn.net/qq_41782425/article/details/85179912?ops_request_misc=&request_id=&biz_id=102&utm_term=github%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187">最新 GitHub 账号注册（详细图解——CSDN。</a></p><p>git 的下载安装可参考这篇博文进行下载安装 <a href="https://blog.csdn.net/mukes/article/details/115693833?ops_request_misc=%7B%22request_id%22:%22162902395616780274116656%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=162902395616780274116656&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115693833.first_rank_v2_pc_rank_v29&utm_term=git%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">Git 详细安装教程（详解 Git 安装过程的每一个步骤）——CSDN</a>。</p><h2 id="绑定-GitHub"><a href="#绑定-GitHub" class="headerlink" title="绑定 GitHub"></a>绑定 GitHub</h2><p>为了方便向 GitHub 的仓库上传文件，我利用 SSH（安全外壳协议，Secure Shell 的缩写）绑定 GitHub 并提交文件，这样既方便快捷，又安全可靠。详细了解 SSH 协议可参考这篇文章 <a href="https://blog.csdn.net/qq_35246620/article/details/54317740">详述 SSH 的原理及其应用——CSDN</a>。</p><h3 id="1-绑定-GitHub"><a href="#1-绑定-GitHub" class="headerlink" title="1. 绑定 GitHub"></a>1. 绑定 GitHub</h3><p>利用 git 上传文件到 GitHub 首先得利用 SSH 登录远程主机，有两种登录方式：口令登录和公钥登录。口令登录需每次输入密码，较为麻烦，公钥登录省去了输入密码的步骤，更为快捷方便一些。所以我才用了公钥登录的方式。</p><p>首先需要在 GitHub 上添加 SSH key 配置，如果已经安装好 Git Bash，应该会自带有 SSH，可以在 Git Bash 中输入 ssh 命令来检查一下本机是否安装。</p><img src="https://s2.loli.net/2025/04/15/ZkVYpzmgKThbuUH.png" alt="添加SShkey步骤1" style="zoom:67%;" /><img src="https://s2.loli.net/2025/04/15/L6FiGXx9tebEyjn.png" alt="绑定SSHkey步骤2" style="zoom: 80%;" /><p>如上图所示，即已经成功安装 SSH。</p><p>接着输入命令 *<em>ssh-keygen -t rsa ** （注意空格），表示指定 RSA 算法生成密钥，然后按四次回车键，会生成两个文件，分别为秘钥 id_rsa 和公钥 id_rsa.pub. 根据 Git Bash 上显示的目录找到所述文件。</em>（注意：git 中的复制粘贴不是 Ctrl+C 和 Ctrl+V，而是 Ctrl+insert 和 Shift+insert.）*</p><img src="https://s2.loli.net/2025/04/15/VRQgDl6GXJwhyiH.png" alt="SSH安装成功" style="zoom: 80%;" /><p>如果根据目录找不到也没关系，可以直接在 Git Bash 中输入以下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh </span><br><span class="line">$ ls</span><br><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure><p>接下来我们要做的事情就是把公钥 id_rsa.pub 的内容添加到 GitHub。复制公钥 id_rsa.pub 文件里的内容，进入到自己的 GitHub 主页，点击右上角的头像，再找到 <strong>Setting</strong> 点击。</p><p><img src="https://s2.loli.net/2025/04/15/VC1Aaw7cqYNgE3S.png" alt="setting"></p><p>如下图，先点击 <em><strong>SSH and GPG keys</strong></em>，再点击 <em><strong>New SSH key。</strong></em></p><p><img src="https://s2.loli.net/2025/04/15/P23KAWokS5puUzl.png" alt="新建SSHkey"></p><p>将刚才复制的公钥填写到下面 <em><strong>Key</strong></em> 的大框里，上面是标题，可填可不填，最后点击下面的 <em><strong>Add SSH key</strong></em> 。</p><p><img src="https://s2.loli.net/2025/04/15/MuvN6wOty9LUA3X.png" alt="addSSHkey"></p><p>然后我们可以通过 Git Bash 中输入 ssh -T <a href="mailto:git@github.com">git@github.com</a> 进行检验是否验证成功，第一次会询问，填写 yes，回车就好。</p><img src="https://s2.loli.net/2025/04/15/glqdKO9WrPHbRzJ.png" alt="验证SSH绑定成功" style="zoom:80%;" /><h3 id="2-提交文件"><a href="#2-提交文件" class="headerlink" title="2. 提交文件"></a>2. 提交文件</h3><p>提交文件有两种方法：</p><p><strong>① 本地没有 git 仓库</strong></p><blockquote><ol><li>直接将远程仓库 clone 到本地；</li><li>将文件添加并 commit 到本地仓库；</li><li>将本地仓库的内容 push 到远程仓库。</li></ol></blockquote><p><strong>② 本地有 Git 仓库，并且已经进行了多次 commit 操作</strong></p><blockquote><ol><li>建立一个本地仓库进入，init 初始化；</li><li>关联远程仓库；</li><li>同步远程仓库和本地仓库；</li><li>将文件添加提交到本地仓库；</li><li>将本地仓库的内容 push 到远程仓库。</li></ol></blockquote><p>下面展开详细讲解一下两种方法如何使用：</p><p><strong>① 本地没有 git 仓库</strong>：</p><p>首先进入自己的 GitHub 主页，创建一个新项目，我这里将新项目命名为《First-Demo》，点击进入</p><p><img src="https://s2.loli.net/2025/04/15/ibeTWXIQrm2xZBC.png" alt="firstDemo"></p><p>点击 <strong>Code</strong>，再点击<strong>SSH</strong>，点击网址后面的复制图标将路径复制。</p><p><img src="https://s2.loli.net/2025/04/15/jVGZzLTWHdqBo98.png" alt="复制SSH路径"></p><p>然后打开 Git Bash 进入到自己准备存储 Git 仓库的目录</p><img src="https://s2.loli.net/2025/04/15/pbXJLBydmwkYSIl.png" alt="too many错误" style="zoom:80%;" /><p>这里进入是时我出现了 “bash: cd: too many arguments” 的错误，是因为路径中包含了空格导致的，只需要将路径中有空格的部分用双引号包起来就可以解决了。</p><img src="https://s2.loli.net/2025/04/15/NDCx1VFsbSG3KIU.png" alt="too many解决" style="zoom:80%;" /><p>这样就进入到仓库所在目录，然后运行命令 git clone <a href="mailto:&#x67;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#111;&#x6d;">&#x67;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#111;&#x6d;</a>:7948…（把刚刚复制的地址粘贴过来），将远程仓库 clone 到本地。</p><img src="https://s2.loli.net/2025/04/15/PVAL4jgtBSnDsIl.png" alt="clone成功" style="zoom:80%;" /><p>上图就证明 clone 成功了，我们可以打开仓库所在的目录，检验一下是否 clone 正确，可以看到本地内容与 GitHub 上的内容完全一致。</p><p>接下来我们在本地的仓库新建一个文件，然后从此目录进入 Git Bash，输入 git status 命令查看仓库状态：</p><img src="https://s2.loli.net/2025/04/15/56Nebj7yMhZmQPc.png" alt="本地新建文件" style="zoom:80%;" /><p>可以看到我们刚刚新建的文件并没有被追踪，现在用 git add 命令将文件添加到「临时缓冲区」，再用 git commit -m “提交信息” 将其提交到本地仓库，如下图：</p><img src="https://s2.loli.net/2025/04/15/wSjF4gWbfxsc6mD.png" alt="commit" style="zoom:80%;" /><p>然后就可以输入 git push origin master 命令，将本地仓库提交到远程仓库，origin 是远程主机的名字</p><img src="https://s2.loli.net/2025/04/15/TX8SxitsrQRzL2p.png" alt="push" style="zoom:80%;" /><p>此时再看 GitHub 主页上仓库里已有我们更新提交的文件了</p><p><img src="https://s2.loli.net/2025/04/15/xXstRuHTNdz64eg.png" alt="添加新文件"></p><hr><p><strong>② 本地有 Git 仓库，并且已经进行了多次 commit 操作</strong></p><p>首先，我们建立一个本地仓库 secondDemo，使用 git init 命令初始化这个仓库</p><img src="https://s2.loli.net/2025/04/15/COt1Kys98vPlNHk.png" alt="secondDemo" style="zoom:80%;" /><img src="https://s2.loli.net/2025/04/15/2MfvgyrQP5Z43oC.png" alt="gitinit" style="zoom:80%;" /><p>输入 git remote add origin <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#117;&#98;&#46;&#99;&#x6f;&#109;">&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#117;&#98;&#46;&#99;&#x6f;&#109;</a>:7948…命令，关联远程仓库，接着输入 git pull origin master 命令，同步远程仓库和本地仓库 git</p><img src="https://s2.loli.net/2025/04/15/CfnAhrLd2xUbKXz.png" alt="同步" style="zoom:80%;" /><p>然后我们打开本地仓库就可以看到，和远程仓库中的内容一致了，接下来的操作与第①种方法大同小异，add、push、commit 等操作。</p><h2 id="3-购买域名"><a href="#3-购买域名" class="headerlink" title="3. 购买域名"></a>3. 购买域名</h2><p>搭建自己的个人博客网站，当然需要一个专属于自己的域名啦，我本人的域名是在阿里云的<a href="https://wanwang.aliyun.com/">万网 </a> 购买的，首年还有优惠，先查询一下自己心仪的域名能否使用，接下来需要在阿里云注册账号，就可以购买一个属于自己的域名啦！</p><h2 id="4-安装-node-js"><a href="#4-安装-node-js" class="headerlink" title="4. 安装 node.js"></a>4. 安装 node.js</h2><p><strong>更新：</strong></p><p>先下载 nvm (node.js version management)，顾名思义是一个 nodejs 的版本管理工具。通过它可以安装和切换不同版本的 nodejs。方便之后的操作，可以<a href="https://github.com/coreybutler/nvm-windows/releases">点击此处 </a> 下载 nvm，下载 Windows 版本</p><ul><li>nvm-noinstall.zip：绿色免安装版，但使用时需进行配置。</li><li>nvm-setup.zip：安装版，推荐使用</li></ul><p><img src="https://s2.loli.net/2025/04/15/aq5eY64IkLwvp1i.png" alt="nvm下载"></p><p>下载好之后一路 next 安装完成，打开 CMD，输入命令 <code>nvm -v</code>，若出现以下界面则证明安装成功：</p><p><img src="https://s2.loli.net/2025/04/15/3ngb2qaxhPsJmQp.png" alt="nvm安装成功"></p><p>接下来输入命令 <code>nvm install 14.17.5</code> 即可安装 14.17.5 版本的 node.js 和 npm。</p><p><img src="https://s2.loli.net/2025/04/15/IZgL9eFr7MAkaBP.jpg" alt="安装node"></p><p>之后输入命令 <code>nvm use 14.17.5</code>，即可使用该版本的 node 与 npm </p><p><img src="https://s2.loli.net/2025/04/15/xDvcWzdibR61Buq.jpg" alt="使用node版本"></p><p>以下附上常用的 nvm 命令：</p><ol><li><code>nvm arch</code> ：显示 node 是运行在 32 位还是 64 位。</li><li><code>nvm install &lt;version&gt; [arch]</code> ：安装 node， version 是特定版本也可以是最新稳定版本 latest。可选参数 arch 指定安装 32 位还是 64 位版本，默认是系统位数。可以添加–insecure 绕过远程服务器的 SSL。</li><li><code>nvm list [available]</code> ：显示已安装的列表。可选参数 available，显示可安装的所有版本。list 可简化为 ls。</li><li><code>nvm on</code> ：开启 node.js 版本管理。</li><li><code>nvm off</code> ：关闭 node.js 版本管理。</li><li><code>nvm proxy [url]</code> ：设置下载代理。不加可选参数 url，显示当前代理。将 url 设置为 none 则移除代理。</li><li><code>nvm node_mirror [url]</code> ：设置 node 镜像。默认是 <a href="https://nodejs.org/dist/%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%86%99">https://nodejs.org/dist/。如果不写</a> url，则使用默认 url。设置后可至安装目录 settings.txt 文件查看，也可直接在该文件操作。</li><li><code>nvm npm_mirror [url] </code>：设置 npm 镜像。<a href="https://github.com/npm/cli/archive/%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%86%99">https://github.com/npm/cli/archive/。如果不写</a> url，则使用默认 url。设置后可至安装目录 settings.txt 文件查看，也可直接在该文件操作。</li><li><code>nvm uninstall &lt;version&gt; </code>：卸载指定版本 node。</li><li><code>nvm use [version] [arch] </code>：使用制定版本 node。可指定 32/64 位。</li><li><code>nvm root [path] </code>：设置存储不同版本 node 的目录。如果未设置，默认使用当前目录。</li><li><code>nvm version</code> ：显示 nvm 版本。version 可简化为 v。</li></ol><p><strong>旧：</strong></p><p>下载地址：<a href="https://nodejs.org/en/">node.js 官网 </a></p><p><img src="https://s2.loli.net/2025/04/15/xntU7mSpJuyXDgP.png" alt="下载nodejs"></p><p>点击左面的按钮下载，点击安装包进行安装，详细的安装过程以及环境变量的配置可以参考这篇文章<a href="https://blog.csdn.net/antma/article/details/86104068">node.js 安装详细步骤教程 </a></p><h2 id="5-安装-Hexo"><a href="#5-安装-Hexo" class="headerlink" title="5. 安装 Hexo"></a>5. 安装 Hexo</h2><p>Hexo 就是我个人博客网站的框架，在安装前，先在 GitHub 新建一个仓库</p><p><img src="https://s2.loli.net/2025/04/15/Mcd1PNG5espDvLY.png" alt="新建仓库"></p><p>仓库名称设置为“用户名+github.io”</p><p><img src="https://s2.loli.net/2025/04/15/CRwfXvPNhWa1Z8b.png" alt="仓库名称"></p><p>然后就是安装 Hexo 了，首先在 D 盘新建文件夹“Blog”，打开命令行进入“D:\Blog” ，然后输入命令安装 Hexo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/04/15/HV65UFrkhtc1be9.png" alt="hexo下载"></p><p>安装完成后输入 hexo init 命令初始化博客：</p><p><img src="https://s2.loli.net/2025/04/15/w8JfNDWUI4TGpHr.png" alt="初始化博客"></p><p>然后输入 hexo g 静态部署：</p><p><img src="https://s2.loli.net/2025/04/15/HSwkfVPaYARDBWp.png" alt="静态部署"></p><p>这时网页已经部署完成，输入 hexo s 命令可以查看：</p><p><img src="https://s2.loli.net/2025/04/15/2vMc9t8WDNhTbwk.png" alt="查看部署"></p><p>在浏览器输入 <a href="https://link.zhihu.com/?target=http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%9C%80%E5%8E%9F%E5%A7%8B%E7%9A%84%E6%95%88%E6%9E%9C%E4%BA%86">http://localhost:4000</a> 就可以打开新部署的网页啦：</p><p><img src="https://s2.loli.net/2025/04/15/9wHtG2Ssdao3l1f.png" alt="最初网页"></p><p>最后记得要 ctrl +c 停止运行服务器。</p><h2 id="6-将-Hexo-部署到-GitHub"><a href="#6-将-Hexo-部署到-GitHub" class="headerlink" title="6. 将 Hexo 部署到 GitHub"></a>6. 将 Hexo 部署到 GitHub</h2><p>在 Blog 文件夹中找到_config.yml 文件，用记事本打开，下滑到最底部，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/mayByt/mayByt.github.io.git  #你的仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/04/15/KJ1SqTOzDxfEBMr.png" alt="编辑yml"></p><p>仓库地址在这里：</p><p><img src="https://s2.loli.net/2025/04/15/wHuxEq6ULziFYNA.png" alt="仓库地址"></p><p>然后还是在命令行中进入 D:/Blog，安装 Git 部署插件，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后分别输入以下三条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹 (hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库 (hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><p>完成以后，打开浏览器，输入 <a href="https://maybyt.github.io/">https://xxx.github.io </a> 就可以打开你的网页了：</p><p><img src="https://s2.loli.net/2025/04/15/kQ5vdLBK3X1nEls.png" alt="部署网页"></p><h2 id="7-解析域名"><a href="#7-解析域名" class="headerlink" title="7. 解析域名"></a>7. 解析域名</h2><p>到了这一步，虽然已经可以通过 GitHub 提供的网址访问我们的网页，但是我们想要通过之前购买的专属自己域名来访问，接下来就是绑定自己的域名。</p><p>第一步：首先需要<strong>解析域名</strong>，登陆<a href="https://www.aliyun.com/?spm=5176.12818093.top-nav.dlogo.2c8d16d0eepCRp">万网 </a> 后点击控制台进入域名控制台，在你购买的域名后点击 <em><strong>解析</strong></em> ：</p><p><img src="https://s2.loli.net/2025/04/15/BuWP9NOlxFjSM4U.jpg" alt="域名控制台"></p><p>之后添加两条解析记录，内容如下：</p><p><img src="https://s2.loli.net/2025/04/15/BWZiRuDvNPIXfoc.jpg" alt="添加解析记录"></p><p>其中第一条那个 IPV4 地址可以通过 ping 得到，具体方法是：打开 cmd 输入下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping mayByt.github.io    #ping + 你的 GitHub 的网址</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/04/15/ObucxdJPqmo8C14.jpg" alt="ping"></p><p>第二步：打开 Blog 文件夹里的 source 文件夹，添加 CNAME 文件，可以先创建一个 CNAME.txt 文件，打开后写上域名，不要加 www 否则每次访问都必须加 www，但如果不带有 www，以后访问的时候带不带 www 都可以访问，保存后记得要重命名，将.txt 删除，如下图：</p><p><img src="https://s2.loli.net/2025/04/15/rTnsXucgBSPokvh.jpg" alt="cname"></p><p><img src="https://s2.loli.net/2025/04/15/XJxrnkfBiUGE981.jpg" alt="重命名"></p><p>第三步：打开 Blog 文件夹，右键打开 Git Bash，依次输入下面三条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>接着等待执行完毕后，打开 GitHub 上仓库，可以看到 CNAME 文件已经在项目中了，接着点击 <em><strong>Setting</strong></em> ，打开 <em><strong>Pages</strong></em> ,查看自己的域名已经被保存了。</p><p><img src="https://s2.loli.net/2025/04/15/evFAcGRDQznp7bL.jpg" alt="仓库setting"></p><p>现在，就可以直接在网址栏输入自己的域名访问自己的博客主页啦。</p><p>至此个人网站搭建好了，接下来你还可以通过个性化定制美化自己的网站，我个人网站的优化日志在下一篇文章，大家感兴趣也可以一看~</p><hr><p>更新~</p><p>因为 Hexo 是生成好静态网页上传 git ，这样导致在其他设备上无法自由更新编辑自己的网站，并且源代码无法上传 git ，一旦本机数据发生意外，可能导致自己的网站心血付之东流，因此为我的个人博客添加 git 版本管理。</p><p>首先在 GitHub 新建一个 <em><strong>Blog</strong></em> 仓库：</p><p><img src="https://s2.loli.net/2025/04/15/BP5M6p9XjLShlwI.jpg" alt="新建git仓库"></p><p>然后在本地的网站根目录 <em><strong>Blog</strong></em> 下的 <em><strong>.gitignore</strong></em>文件（若没有则新建一个）里添加 git 时忽略的文件，一般是一些编辑器的配置文件等：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">.vscode/</span><br><span class="line">.idea/</span><br><span class="line">/.idea/</span><br><span class="line">.deploy_git*/</span><br><span class="line">.idea</span><br><span class="line">themes/butterfly/.git</span><br></pre></td></tr></table></figure><p>接着初始化 git 仓库，在本文件夹下 Git Bash 以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>添加当前目录下的所有文件到暂存区：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>提交初始化仓库到本地：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit <span class="literal">-m</span> <span class="string">&quot;初始化仓库&quot;</span></span><br></pre></td></tr></table></figure><p>接着推送到远程的仓库：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="literal">-M</span> maingit remote add origin https://github.com/mayByt/blog.gitgit push <span class="literal">-u</span> origin main</span><br></pre></td></tr></table></figure><p>这样就操作完成啦，就不用担心会遗失自己的源代码，并且可以多终端编辑自己的网站啦~</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构MOOC 02-线性结构3 Reversing Linked List</title>
      <link href="/2021/08/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%2002-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843%20Reversing%20Linked%20List/"/>
      <url>/2021/08/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%2002-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843%20Reversing%20Linked%20List/</url>
      
        <content type="html"><![CDATA[<h1 id="02-线性结构-3-Reversing-Linked-List"><a href="#02-线性结构-3-Reversing-Linked-List" class="headerlink" title="02-线性结构 3 Reversing Linked List"></a><strong>02-线性结构 3 Reversing Linked List</strong></h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>Given a constant <em>K</em> and a singly linked list <em>L</em>, you are supposed to reverse the links of every <em>K</em> elements on <em>L</em>. For example, given <em>L</em> being 1→2→3→4→5→6, if <em>K</em>=3, then you must output 3→2→1→6→5→4; if <em>K</em>=4, you must output 4→3→2→1→5→6.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤10<sup>5</sup>) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p><p>Then <em>N</em> lines follow, each describes a node in the format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>题目大致要求是做一个链表的部分反转，要求按照<code>Address Data Next</code>的格式进行输入，其中 Address 就是当前节点的位置，Data 是节点存储的数据，Next 是下一节点的位置。第一行输入的是链表头结点的位置以及节点的总数还有反转子链的长度 K。最后也按照<code>Address Data Next</code>的格式输出，但是是按照部分反转后的顺序输出。</p><p>根据题目要求搭建程序框架：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">输入链表</span><br><span class="line">链表部分反转操作</span><br><span class="line">输出结果链表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，大体上需要设计输入，反转，输出三个功能的函数。</p><p>① 链表的输入函数</p><p>首先观察题目的输入样例，发现数据是用<code>Address</code> 和 <code>Next</code> 来实现链表功能，因此可以用结构体数组来存储数据，实现链表功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 100005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;   <span class="comment">// 数据</span></span><br><span class="line">    <span class="keyword">int</span> Next;   <span class="comment">// 下一节点地址下标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Link</span>;</span></span><br><span class="line">Link LinkList[MAXLEN];</span><br></pre></td></tr></table></figure><p>按照题目要求，要按照<code>Address Data Next</code> 的格式输入节点数据，而第一行输入略有不同，第一行输入的是链表头结点的位置以及节点的总数还有部分翻转的计数 K。根据以上要求，设计链表的输入函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入函数，返回链表头结点位置下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadList</span><span class="params">(Link &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Head, n, k; <span class="comment">// 起始节点的位置下标，节点总数，反转子链的长度</span></span><br><span class="line">    <span class="keyword">int</span> address, num, next;</span><br><span class="line">    cin &gt;&gt; Head &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; address &gt;&gt; num &gt;&gt; next;</span><br><span class="line">        L[address].Data = num;</span><br><span class="line">        L[address].Next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 链表的反转操作</p><p>该部分是解题的关键，也是难点所在。</p><p>注意这里有一个坑，测试点中有多余节点不在链表上的情况，因此添加一个计数函数，统计链表有效节点，排除不在链表上的离散干扰节点的影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数函数，统计链表有效节点，排除不在链表上的离散干扰节点的影响</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Link L[], <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head; L[i].Next != <span class="number">-1</span>; i = L[i].Next)</span><br><span class="line">        cnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行反转的操作关键在于将下一个结点的 Next 变为上一个节点，但是这样又会导致丢失下一个节点中原来 Next 的位置，因此需要三个指针来完成反转操作。前两个指针用来进行反转，第三个指针临时存储下一节点位置。同时由于反转子链后需要连接下一段子链，因此需要记录上一段子链最后一个节点的位置以及下一段子链第一个节点的位置。</p><p>这里也有小坑，注意考虑 K=1 的情况，此时不需要反转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表反转函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseList</span><span class="params">(Link L[], <span class="keyword">int</span> &amp;head, <span class="keyword">int</span> k)</span>  <span class="comment">// 执行反转操作的链表，链表的头结点位置下标，反转子链的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="built_in">count</span>(L,head);    <span class="comment">// 链表有效长度</span></span><br><span class="line">    <span class="keyword">int</span> p1, p2, p3; <span class="comment">// p1 和 p2 用来执行反转操作，p3 临时存储下一节点位置</span></span><br><span class="line">    <span class="keyword">int</span> nextHead = head;   <span class="comment">// 标记下一段反转子链的第一个结点</span></span><br><span class="line">    <span class="keyword">int</span> lastEnd = <span class="number">-2</span>;   <span class="comment">// 标记上一段反转子链的最后一个节点，因为-1 是链表结束标志，因此赋初值 wei-2</span></span><br><span class="line">    <span class="keyword">bool</span> first = <span class="number">1</span>; <span class="comment">// 标记第一条反转子链，需要将反转后的第一个子链的头结点赋值为整个链表的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(cnt &gt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        p1 = nextHead;</span><br><span class="line">        p2 = L[p1].Next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p3 = L[p2].Next;    <span class="comment">// 将 p2 的下一个结点位置存储</span></span><br><span class="line">            L[p2].Next = p1;    <span class="comment">// 反转 p1 与 p2 的前后顺序，将 p2 的下一个结点指向 p1</span></span><br><span class="line">            p1 = p2;    <span class="comment">// 向后遍历，指针后移</span></span><br><span class="line">            p2 = p3;</span><br><span class="line">        &#125;</span><br><span class="line">        L[nextHead].Next = p3;  <span class="comment">// 链接反转子链与下一段子链</span></span><br><span class="line">        <span class="keyword">if</span>(first)    <span class="comment">// 如果是第一条反转子链</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = p1;  <span class="comment">// 将反转后的第一个子链的头结点赋值为整个链表的头结点</span></span><br><span class="line">            lastEnd = nextHead; <span class="comment">// 反转子链之前的第一个结点变成最后一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            L[lastEnd].Next = p1;   <span class="comment">// 开始新的反转子链</span></span><br><span class="line">            lastEnd = nextHead;</span><br><span class="line">        &#125;</span><br><span class="line">        nextHead = p2;</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">        cnt -= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 打印链表的函数</p><p>因为输出限制了格式需要将地址按照 5 位输出，并且空位补零，因此使用 C 语言的 prinf() 函数控制格式，“%05d”控制 5 位补零。但是由于最后一个结点的 Next 为-1，因此需要另外单独控制输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印链表函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(Link L[], <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = head;</span><br><span class="line">    <span class="keyword">while</span>(L[i].Next != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>, i, L[i].Data, L[i].Next);</span><br><span class="line">        i = L[i].Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %d\n&quot;</span>,i, L[i].Data, L[i].Next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 100005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;   <span class="comment">// 数据</span></span><br><span class="line">    <span class="keyword">int</span> Next;   <span class="comment">// 下一节点地址下标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Link</span>;</span></span><br><span class="line">Link LinkList[MAXLEN];  <span class="comment">// 结构体数组表示链表</span></span><br><span class="line"><span class="keyword">int</span> k, head;    <span class="comment">// 反转子链长度，链表头</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadList</span><span class="params">(Link[])</span></span>;    <span class="comment">// 输入函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseList</span><span class="params">(Link L[], <span class="keyword">int</span> &amp;head, <span class="keyword">int</span> k)</span></span>; <span class="comment">// 链表反转函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(Link L[], <span class="keyword">int</span> head)</span></span>;   <span class="comment">// 打印链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="built_in">ReadList</span>(LinkList);</span><br><span class="line">    <span class="built_in">ReverseList</span>(LinkList, head, k);</span><br><span class="line">    <span class="built_in">PrintList</span>(LinkList,head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入函数，返回链表头结点位置下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadList</span><span class="params">(Link L[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Head, n; <span class="comment">// 起始节点的位置下标，节点总数，反转子链的长度</span></span><br><span class="line">    <span class="keyword">int</span> address, num, next;</span><br><span class="line">    cin &gt;&gt; Head &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; address &gt;&gt; num &gt;&gt; next;</span><br><span class="line">        L[address].Data = num;</span><br><span class="line">        L[address].Next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计数函数，统计链表有效节点，排除不在链表上的离散干扰节点的影响</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Link L[], <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head; L[i].Next != <span class="number">-1</span>; i = L[i].Next)</span><br><span class="line">        cnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链表反转函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseList</span><span class="params">(Link L[], <span class="keyword">int</span> &amp;head, <span class="keyword">int</span> k)</span>  <span class="comment">// 执行反转操作的链表，链表的头结点位置下标，反转子链的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="built_in">count</span>(L,head);    <span class="comment">// 链表有效长度</span></span><br><span class="line">    <span class="keyword">int</span> p1, p2, p3; <span class="comment">// p1 和 p2 用来执行反转操作，p3 临时存储下一节点位置</span></span><br><span class="line">    <span class="keyword">int</span> nextHead = head;   <span class="comment">// 标记下一段反转子链的第一个结点</span></span><br><span class="line">    <span class="keyword">int</span> lastEnd = <span class="number">-2</span>;   <span class="comment">// 标记上一段反转子链的最后一个节点，因为-1 是链表结束标志，因此赋初值 wei-2</span></span><br><span class="line">    <span class="keyword">bool</span> first = <span class="number">1</span>; <span class="comment">// 标记第一条反转子链，需要将反转后的第一个子链的头结点赋值为整个链表的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(cnt &gt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        p1 = nextHead;</span><br><span class="line">        p2 = L[p1].Next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p3 = L[p2].Next;    <span class="comment">// 将 p2 的下一个结点位置存储</span></span><br><span class="line">            L[p2].Next = p1;    <span class="comment">// 反转 p1 与 p2 的前后顺序，将 p2 的下一个结点指向 p1</span></span><br><span class="line">            p1 = p2;    <span class="comment">// 向后遍历，指针后移</span></span><br><span class="line">            p2 = p3;</span><br><span class="line">        &#125;</span><br><span class="line">        L[nextHead].Next = p3;  <span class="comment">// 链接反转子链与下一段子链</span></span><br><span class="line">        <span class="keyword">if</span>(first)    <span class="comment">// 如果是第一条反转子链</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = p1;  <span class="comment">// 将反转后的第一个子链的头结点赋值为整个链表的头结点</span></span><br><span class="line">            lastEnd = nextHead; <span class="comment">// 反转子链之前的第一个结点变成最后一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            L[lastEnd].Next = p1;   <span class="comment">// 开始新的反转子链</span></span><br><span class="line">            lastEnd = nextHead;</span><br><span class="line">        &#125;</span><br><span class="line">        nextHead = p2;</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">        cnt -= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印链表函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(Link L[], <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = head;</span><br><span class="line">    <span class="keyword">while</span>(L[i].Next != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>, i, L[i].Data, L[i].Next);</span><br><span class="line">        i = L[i].Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %d\n&quot;</span>,i, L[i].Data, L[i].Next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构MOOC 02-线性结构2 一元多项式的乘法与加法运算</title>
      <link href="/2021/08/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%2002-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842%20%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/"/>
      <url>/2021/08/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%2002-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842%20%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="02-线性结构-2-一元多项式的乘法与加法运算"><a href="#02-线性结构-2-一元多项式的乘法与加法运算" class="headerlink" title="02-线性结构 2 一元多项式的乘法与加法运算"></a><strong>02-线性结构 2 一元多项式的乘法与加法运算</strong></h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>设计函数分别求两个一元多项式的乘积与和。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入分 2 行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出分 2 行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>根据输入样例，多项式均是以指数递减的方式输入，可用动态数组和单链表来表示多项式，本题采用单链表来表示。链表结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomial</span>;</span>   <span class="comment">// 多项式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> coef;   <span class="comment">// 系数</span></span><br><span class="line">    <span class="keyword">int</span> expon;  <span class="comment">// 指数</span></span><br><span class="line">    Polynomial link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照题目要求搭建程序框架：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">读取多项式 1</span><br><span class="line">读取多项式 2</span><br><span class="line">乘法运算并输出</span><br><span class="line">加法运算并输出</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，需要设计读取，加法和乘法运算，输出四个功能的函数。</p><p>① 读取函数</p><p>根据题目的输入样例，设计读取函数，由于链表中结点链接到链表中从操作频繁，增加设计一个链接函数 Attach()，方便操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链接函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> e, Polynomial *pRear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial t = <span class="keyword">new</span> <span class="built_in">Polynomial</span>();</span><br><span class="line">    t-&gt;coef = c;    <span class="comment">// 给新节点赋值</span></span><br><span class="line">    t-&gt;expon = e;</span><br><span class="line">    t-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;link = t;</span><br><span class="line">    *pReal = t; <span class="comment">// 修改*pRear 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取多项式函数</span></span><br><span class="line"><span class="function">Polynomial <span class="title">ReadPoly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial P = <span class="keyword">new</span> <span class="built_in">Polynomial</span>();  <span class="comment">// 临时生成链表头空节点</span></span><br><span class="line">    Polynomial Rear, t;</span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">int</span> n, c, e;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; e;</span><br><span class="line">        <span class="built_in">Attach</span>(c,e,&amp;Rear);</span><br><span class="line">    &#125;</span><br><span class="line">    t = P;  <span class="comment">// 删除临时生成的头节点</span></span><br><span class="line">    P = P-&gt;link;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 多项式相加函数</p><p>两个多项式相加，就是逐项比较两个链表每一项，将指数相同的项系数相加得到新的项，指数较大的项链接到结果链表后并将指针向后移，直到其中一个链表遍历完，将另一链表剩余部分全部连接到结果链表后。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多项式相加函数</span></span><br><span class="line"><span class="function">Polynomial <span class="title">AddPoly</span><span class="params">(Polynomial P1, Polynomial P2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Polynomial Rear, t1, t2, t;</span><br><span class="line">    t1 = P1;</span><br><span class="line">    t2 = P2;</span><br><span class="line">    Polynomial P = <span class="keyword">new</span> PolyNode;</span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span>(t1 &amp;&amp; t2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;expon == t2-&gt;expon)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = t1-&gt;coef + t2-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span>(sum != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Attach</span>(sum,t1-&gt;expon,&amp;Rear);</span><br><span class="line">                t1 = t1-&gt;link;</span><br><span class="line">                t2 = t2-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                t1 = t1-&gt;link;</span><br><span class="line">                t2 = t2-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t1-&gt;expon &gt; t2-&gt;expon)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Attach</span>(t1-&gt;coef,t1-&gt;expon,&amp;Rear);</span><br><span class="line">            t1 = t1-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t1-&gt;expon &lt; t2-&gt;expon)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Attach</span>(t2-&gt;coef,t2-&gt;expon,&amp;Rear);</span><br><span class="line">            t2 = t2-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;t1;t1=t1-&gt;link)    <span class="built_in">Attach</span>(t1-&gt;coef,t1-&gt;expon,&amp;Rear);</span><br><span class="line">    <span class="keyword">for</span>(;t2;t2=t2-&gt;link)    <span class="built_in">Attach</span>(t2-&gt;coef,t2-&gt;expon,&amp;Rear);</span><br><span class="line">    Rear-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    t = P;</span><br><span class="line">    P = P-&gt;link;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 多项式相乘函数</p><p>两个多项式相乘较为麻烦，可以分解为两个主要步骤：</p><p>​    &lt;1&gt; 将乘法运算转变为加法运算</p><p>​            将 P1 当前项（c<sub>i</sub> ,e<sub>i</sub> ) 乘 P2 多项式，再加到结果多项式里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1 = P1; t2 = P2;</span><br><span class="line">Polynomial P = <span class="keyword">new</span> <span class="built_in">Polynomial</span>();</span><br><span class="line">Rear = P;</span><br><span class="line"><span class="keyword">while</span>(t2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Attach</span>(t1-&gt;coef*t2-&gt;coef,t1-&gt;expon+t2-&gt;expon,&amp;Rear);</span><br><span class="line">t2 = t2-&gt;link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    &lt;2&gt; 逐项插入</p><p>​            将 P1 当前项（c1<sub>i</sub> ,e1<sub>i</sub> ) 乘 P2 当前项（c2<sub>i</sub> ,e2<sub>i</sub> )，并插入到结果多项式中。关键是要找到插入位置。其中结果多项式的初始位置可由 P1 的第一项乘以 P2 获得。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">t1 = t1-&gt;link;</span><br><span class="line">    <span class="keyword">while</span>(t1)</span><br><span class="line">    &#123;</span><br><span class="line">        t2 = P2;</span><br><span class="line">        Rear = P;   <span class="comment">// 每一次的 t1 指向的多项式乘以 t2 的每一项后，Rear 都重新指回 P 的头结点，以便下一次得到的 t1 和 t2 的乘积插入 P</span></span><br><span class="line">        <span class="keyword">while</span>(t2)</span><br><span class="line">        &#123;</span><br><span class="line">            c = t1-&gt;coef * t2-&gt;coef;</span><br><span class="line">            e = t1-&gt;expon + t2-&gt;expon;</span><br><span class="line">            <span class="keyword">while</span> (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) <span class="comment">// 当 Rear 的下一项不为空且下一项的指数比当前的乘积 e 大时，Rear 后移</span></span><br><span class="line">            &#123;</span><br><span class="line">                Rear = Rear-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Rear-&gt;link-&gt;coef+c)  <span class="comment">// 指数相同时，结果系数不为零</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Rear-&gt;link-&gt;coef+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">// 指数相同时，结果系数为 0</span></span><br><span class="line">                &#123;</span><br><span class="line">                    t = Rear-&gt;link; <span class="comment">// 将零项删除</span></span><br><span class="line">                    Rear-&gt;link = t-&gt;link;</span><br><span class="line">                    <span class="built_in">free</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// 当前多项式的指数大于 Rear 的下一项</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = <span class="keyword">new</span> PolyNode;</span><br><span class="line">                t-&gt;coef = c;</span><br><span class="line">                t-&gt;expon = e;</span><br><span class="line">                t-&gt;link = Rear-&gt;link;</span><br><span class="line">                Rear-&gt;link = t;</span><br><span class="line">                Rear = Rear-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">            t2 = t2-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        t1 = t1-&gt;link;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>④ 输出函数</p><p>​    要按照输出样例的格式输出，注意到输出的多项式每组系数和指数间都有空格，每个项之间也有空格，但是首尾没有空格。</p><p>​    可以把每组数据看作，“空格+系数+指数”，但是第一项没有空格，因此可以设置一个 flag 来控制输出，flag 初始值为 0，在执行一步输出操作后置为 1，只有 flag 为 1 时才输出空格。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印结果多项式函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPoly</span><span class="params">(Polynomial P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!P)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(P)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; P-&gt;coef &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; P-&gt;expon;</span><br><span class="line">            P = P-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdC++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomial</span>;</span>   <span class="comment">// 多项式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> coef;   <span class="comment">// 系数</span></span><br><span class="line">    <span class="keyword">int</span> expon;  <span class="comment">// 指数</span></span><br><span class="line">    Polynomial link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> e, Polynomial *pRear)</span></span>;  <span class="comment">// 链接结点到链表的函数</span></span><br><span class="line"><span class="function">Polynomial <span class="title">ReadPoly</span><span class="params">()</span></span>; <span class="comment">// 读取多项式函数</span></span><br><span class="line"><span class="function">Polynomial <span class="title">AddPoly</span><span class="params">(Polynomial P1, Polynomial P2)</span></span>;    <span class="comment">// 多项式相加</span></span><br><span class="line"><span class="function">Polynomial <span class="title">MultPoly</span><span class="params">(Polynomial P1, Polynomial P2)</span></span>;  <span class="comment">// 多项式相乘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPoly</span><span class="params">(Polynomial P)</span></span>;   <span class="comment">// 打印结果多项式函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial P1, P2, Pa, Pm;</span><br><span class="line">    P1 = <span class="built_in">ReadPoly</span>();</span><br><span class="line">    P2 = <span class="built_in">ReadPoly</span>();</span><br><span class="line">    Pa = <span class="built_in">AddPoly</span>(P1,P2);</span><br><span class="line">    Pm = <span class="built_in">MultPoly</span>(P1,P2);</span><br><span class="line">    <span class="built_in">PrintPoly</span>(Pm);</span><br><span class="line">    <span class="built_in">PrintPoly</span>(Pa);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> e, Polynomial *pRear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial t = <span class="keyword">new</span> PolyNode;</span><br><span class="line">    t-&gt;coef = c;    <span class="comment">// 给新节点赋值</span></span><br><span class="line">    t-&gt;expon = e;</span><br><span class="line">    t-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;link = t;</span><br><span class="line">    *pRear = t; <span class="comment">// 修改*pRear 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取多项式函数</span></span><br><span class="line"><span class="function">Polynomial <span class="title">ReadPoly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial P = <span class="keyword">new</span> PolyNode;  <span class="comment">// 临时生成链表头空节点</span></span><br><span class="line">    Polynomial Rear, t;</span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">int</span> n, c, e;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; e;</span><br><span class="line">        <span class="built_in">Attach</span>(c,e,&amp;Rear);</span><br><span class="line">    &#125;</span><br><span class="line">    t = P;  <span class="comment">// 删除临时生成的头节点</span></span><br><span class="line">    P = P-&gt;link;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多项式相加函数</span></span><br><span class="line"><span class="function">Polynomial <span class="title">AddPoly</span><span class="params">(Polynomial P1, Polynomial P2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Polynomial Rear, t1, t2, t;</span><br><span class="line">    t1 = P1;</span><br><span class="line">    t2 = P2;</span><br><span class="line">    Polynomial P = <span class="keyword">new</span> PolyNode;</span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span>(t1 &amp;&amp; t2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;expon == t2-&gt;expon)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = t1-&gt;coef + t2-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span>(sum != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Attach</span>(sum,t1-&gt;expon,&amp;Rear);</span><br><span class="line">                t1 = t1-&gt;link;</span><br><span class="line">                t2 = t2-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                t1 = t1-&gt;link;</span><br><span class="line">                t2 = t2-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t1-&gt;expon &gt; t2-&gt;expon)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Attach</span>(t1-&gt;coef,t1-&gt;expon,&amp;Rear);</span><br><span class="line">            t1 = t1-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t1-&gt;expon &lt; t2-&gt;expon)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Attach</span>(t2-&gt;coef,t2-&gt;expon,&amp;Rear);</span><br><span class="line">            t2 = t2-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;t1;t1=t1-&gt;link)    <span class="built_in">Attach</span>(t1-&gt;coef,t1-&gt;expon,&amp;Rear);</span><br><span class="line">    <span class="keyword">for</span>(;t2;t2=t2-&gt;link)    <span class="built_in">Attach</span>(t2-&gt;coef,t2-&gt;expon,&amp;Rear);</span><br><span class="line">    Rear-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    t = P;</span><br><span class="line">    P = P-&gt;link;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多项式相乘函数</span></span><br><span class="line"><span class="function">Polynomial <span class="title">MultPoly</span><span class="params">(Polynomial P1, Polynomial P2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, e;</span><br><span class="line">    <span class="keyword">if</span>(!P1 || !P2)  <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">// 判断两个多项式都不为零多项式</span></span><br><span class="line">    Polynomial t, t1, t2, Rear;</span><br><span class="line">    t1 = P1;    t2 = P2;</span><br><span class="line">    Polynomial P = <span class="keyword">new</span> PolyNode;</span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span>(t2)   <span class="comment">// 先用 P1 的第一项乘以 P2 作为结果多项式的初始值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Attach</span>(t1-&gt;coef*t2-&gt;coef,t1-&gt;expon+t2-&gt;expon,&amp;Rear);</span><br><span class="line">        t2 = t2-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = t1-&gt;link;</span><br><span class="line">    <span class="keyword">while</span>(t1)</span><br><span class="line">    &#123;</span><br><span class="line">        t2 = P2;</span><br><span class="line">        Rear = P;   <span class="comment">// 每一次的 t1 指向的多项式乘以 t2 的每一项后，Rear 都重新指回 P 的头结点，以便下一次得到的 t1 和 t2 的乘积插入 P</span></span><br><span class="line">        <span class="keyword">while</span>(t2)</span><br><span class="line">        &#123;</span><br><span class="line">            c = t1-&gt;coef * t2-&gt;coef;</span><br><span class="line">            e = t1-&gt;expon + t2-&gt;expon;</span><br><span class="line">            <span class="keyword">while</span> (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) <span class="comment">// 当 Rear 的下一项不为空且下一项的指数比当前的乘积 e 大时，Rear 后移</span></span><br><span class="line">            &#123;</span><br><span class="line">                Rear = Rear-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Rear-&gt;link-&gt;coef+c)  <span class="comment">// 指数相同时，结果系数不为零</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Rear-&gt;link-&gt;coef+=c;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="comment">// 指数相同时，结果系数为 0</span></span><br><span class="line">                &#123;</span><br><span class="line">                    t = Rear-&gt;link; <span class="comment">// 将零项删除</span></span><br><span class="line">                    Rear-&gt;link = t-&gt;link;</span><br><span class="line">                    <span class="built_in">free</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// 当前多项式的指数大于 Rear 的下一项</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = <span class="keyword">new</span> PolyNode;</span><br><span class="line">                t-&gt;coef = c;</span><br><span class="line">                t-&gt;expon = e;</span><br><span class="line">                t-&gt;link = Rear-&gt;link;</span><br><span class="line">                Rear-&gt;link = t;</span><br><span class="line">                Rear = Rear-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">            t2 = t2-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        t1 = t1-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = P;</span><br><span class="line">    P = P-&gt;link;</span><br><span class="line">    <span class="built_in">free</span>(t2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果多项式函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPoly</span><span class="params">(Polynomial P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!P)  <span class="comment">// 注意判断 P 是否为 0 多项式</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0 0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(P)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; P-&gt;coef &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; P-&gt;expon;</span><br><span class="line">            P = P-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构MOOC课后习题 02-线性结构1 两个有序链表序列的合并（函数题）</title>
      <link href="/2021/08/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%2002-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%841%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6%EF%BC%88%E5%87%BD%E6%95%B0%E9%A2%98%EF%BC%89/"/>
      <url>/2021/08/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%2002-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%841%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6%EF%BC%88%E5%87%BD%E6%95%B0%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="02-线性结构-1-两个有序链表序列的合并（函数题）"><a href="#02-线性结构-1-两个有序链表序列的合并（函数题）" class="headerlink" title="02-线性结构 1 两个有序链表序列的合并（函数题）"></a><strong>02-线性结构 1 两个有序链表序列的合并</strong>（函数题）</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。</p><h3 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>List</code>结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 存储结点数据 */</span></span><br><span class="line">    PtrToNode   Next; <span class="comment">/* 指向下一个结点的指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List; <span class="comment">/* 定义单链表类型 */</span></span><br></pre></td></tr></table></figure><p><code>L1</code>和<code>L2</code>是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数<code>Merge</code>要将<code>L1</code>和<code>L2</code>合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p><h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode   Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">( List L )</span></span>; <span class="comment">/* 细节在此不表；空链表将输出 NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L1, L2, L;</span><br><span class="line">    L1 = <span class="built_in">Read</span>();</span><br><span class="line">    L2 = <span class="built_in">Read</span>();</span><br><span class="line">    L = <span class="built_in">Merge</span>(L1, L2);</span><br><span class="line">    <span class="built_in">Print</span>(L);</span><br><span class="line">    <span class="built_in">Print</span>(L1);</span><br><span class="line">    <span class="built_in">Print</span>(L2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 3 5</span><br><span class="line">5</span><br><span class="line">2 4 6 8 10</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10 </span><br><span class="line">NULL</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct Node));</span><br><span class="line">    List tempL1 = L1-&gt;Next, tempL2 = L2-&gt;Next;</span><br><span class="line">    List head = L;  <span class="comment">// 合并后链表 L 的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(tempL1 &amp;&amp; tempL2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tempL1-&gt;Data &lt;= tempL2-&gt;Data)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;Next = tempL1;</span><br><span class="line">            tempL1 = tempL1-&gt;Next;</span><br><span class="line">            L = L-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;Next = tempL2;</span><br><span class="line">            tempL2 = tempL2-&gt;Next;</span><br><span class="line">            L = L-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;Next = tempL1 ? tempL1 : tempL2; <span class="comment">// 若一个链表遍历完成，则将另一个链表剩余部分直接接到合并后链表</span></span><br><span class="line">    L1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    L2-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>合并链表的操作重点就是将较小链表节点（此处记为 tempL）插入到合并链表之后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> L-&gt;Next = tempL;</span><br><span class="line"><span class="number">2.</span> tempL = tempL-&gt;Next;</span><br><span class="line"><span class="number">3.</span> L = L-&gt;Next;</span><br></pre></td></tr></table></figure><p>直到一个链表遍历完，此时将另一链表剩余部分全部接到合并链表尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L-&gt;Next = tempL1 ? tempL1 : tempL2;</span><br></pre></td></tr></table></figure><p>在题目的输出样例中，L1 和 L2 打印均为 NULL，因此，在函数最后将 L1-&gt;Next 和 L2-&gt;Next 全部置为 NULL。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构MOOC课后习题 01-复杂度3 二分查找 （函数题）</title>
      <link href="/2021/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%2001-%E5%A4%8D%E6%9D%82%E5%BA%A63%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%20%EF%BC%88%E5%87%BD%E6%95%B0%E9%A2%98%EF%BC%89/"/>
      <url>/2021/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%2001-%E5%A4%8D%E6%9D%82%E5%BA%A63%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%20%EF%BC%88%E5%87%BD%E6%95%B0%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="01-复杂度-3-二分查找-（函数题）"><a href="#01-复杂度-3-二分查找-（函数题）" class="headerlink" title="01-复杂度 3 二分查找 （函数题）"></a><strong>01-复杂度 3 二分查找</strong> （函数题）</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>本题要求实现二分查找算法。</p><h3 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>List</code>结构定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; <span class="comment">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>L</code>是用户传入的一个线性表，其中<code>ElementType</code>元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数<code>BinarySearch</code>要查找<code>X</code>在<code>Data</code>中的位置，即数组下标（注意：元素从下标 1 开始存储）。找到则返回下标，否则返回一个特殊的失败标记<code>NotFound</code>。</p><h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NotFound 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; <span class="comment">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">ReadInput</span><span class="params">()</span></span>; <span class="comment">/* 裁判实现，细节不表。元素从下标 1 开始存储 */</span></span><br><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    L = <span class="built_in">ReadInput</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">    P = <span class="built_in">BinarySearch</span>( L, X );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, P);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">12 31 55 89 101</span><br><span class="line">31</span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">26 78 233</span><br><span class="line">31</span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position t = <span class="number">0</span>, l = <span class="number">1</span>, r = L-&gt;Last;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        t = (l+r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(X == L-&gt;Data[t])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; L-&gt;Data[t])</span><br><span class="line">        &#123;</span><br><span class="line">            l = t + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; L-&gt;Data[t])</span><br><span class="line">        &#123;</span><br><span class="line">            r = t - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NotFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>简单的二分思想，设置一个 temp 不断寻找待查区间下标的中间值，与输入的数据比较，如果 temp 较大，则更新待查区间右端点为 temp-1；若 temp 较小，则更新待查区间左端点为 temp+1；若与 temp 相等，则返回 temp，即该元素在线性表中的位置下标；若出现了待查区间左端点下标大于右端点下标的情况，则说明未在线性表中查找到该元素，返回 NotFound。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构MOOC课后习题 01-复杂度2 Maximum Subsequence Sum</title>
      <link href="/2021/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%2001-%E5%A4%8D%E6%9D%82%E5%BA%A62%20Maximum%20Subsequence%20Sum/"/>
      <url>/2021/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%2001-%E5%A4%8D%E6%9D%82%E5%BA%A62%20Maximum%20Subsequence%20Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="01-复杂度-2-Maximum-Subsequence-Sum"><a href="#01-复杂度-2-Maximum-Subsequence-Sum" class="headerlink" title="01-复杂度 2 Maximum Subsequence Sum"></a><strong>01-复杂度 2 Maximum Subsequence Sum</strong></h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>Given a sequence of <em>K</em> integers { <em>N</em><sub>1</sub>, <em>N</em><sub>2</sub>, …, <em>N</em><sub><em>K</em> </sub>}. A continuous subsequence is defined to be { <em>N</em><sub><em>i</em></sub>, <em>N</em><sub><em>i</em>+1</sub>, …, <em>N</em><sub><em>j</em> </sub> } where 1≤<em>i</em>≤<em>j</em>≤<em>K</em>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p><p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em> numbers, separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">int</span> MaxSum = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ThisSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = n, templeft = <span class="number">1</span>, tempright = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    tempright = i;</span><br><span class="line">    ThisSum += a[i];</span><br><span class="line">    <span class="keyword">if</span>(ThisSum &gt; MaxSum)&#123;</span><br><span class="line">    left = templeft;</span><br><span class="line">            right = tempright;</span><br><span class="line">    MaxSum = ThisSum;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(ThisSum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    ThisSum = <span class="number">0</span>;</span><br><span class="line">    templeft = i+<span class="number">1</span>;</span><br><span class="line">    tempright=i+<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(MaxSum&lt;<span class="number">0</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; MaxSum &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[left] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;a [right] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>这道题是上一道题的难度加大版，需要记录最大子列和首尾的数字，因此需要构建一个数组来存放数字序列以方便计数，注意这里有两个坑，测试时多次未 AC。</p><p>① 如果序列全为负数时，要输出 ”0 序列首位数字 序列末尾数字“，如果序列中有 0 存在，其他数字均为负数时，则输出” 0 0 0 “。</p><p>② 如果存在多个并列的最大子列和，要输出下标更小的那一组。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构MOOC课后习题 01-复杂度1 最大子列和问题</title>
      <link href="/2021/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%2001-%E5%A4%8D%E6%9D%82%E5%BA%A61%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2021/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84MOOC%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%2001-%E5%A4%8D%E6%9D%82%E5%BA%A61%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="01-复杂度-1-最大子列和问题"><a href="#01-复杂度-1-最大子列和问题" class="headerlink" title="01-复杂度 1 最大子列和问题"></a><strong>01-复杂度 1 最大子列和问题</strong></h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定<em>K</em>个整数组成的序列 { <em>N</em><sub>1</sub>, <em>N</em><sub>2</sub>, …, <em>N</em><sub><em>K</em> </sub>}，“连续子列”被定义为 { <em>N</em><sub><em>i</em></sub>, <em>N</em><sub><em>i</em>+1</sub>, …, <em>N</em><sub><em>j</em> </sub>}，其中 1≤<em>i</em>≤<em>j</em>≤<em>K</em>。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列 { -2, 11, -4, 13, -5, -2 }，其连续子列 { 11, -4, 13 } 有最大的和 20。现要求你编写程序，计算给定整数序列的最大子列和。</p><p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p><ul><li>数据 1：与样例等价，测试基本正确性；</li><li>数据 2：10<sup>2</sup> 个随机整数；</li><li>数据 3：10<sup>3</sup> 个随机整数；</li><li>数据 4：10<sup>4</sup> 个随机整数；</li><li>数据 5：10<sup>5</sup> 个随机整数；</li></ul><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第 1 行给出正整数<em>K</em> (≤100000)；第 2 行给出<em>K</em>个整数，其间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出 0。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">-2 11 -4 13 -5 -2</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> maxsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> thissum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        thissum += n;</span><br><span class="line">        <span class="keyword">if</span>(thissum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            thissum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(thissum &gt; maxsum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxsum = thissum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxsum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用“在线处理”方法，设置两个变量，maxsum（最大子列和），thissum（当前自列和）。循环输入数列数字，加入 thissum（当前子列和），一旦 thissum 的大小小于 0 就说明之后再加任何的数字都只能变小，此时将 thissum 置 0，进入下一次循环。每次循环更新 maxsum 大小，最后循环结束，输出 maxsum。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-025 正整数A+B</title>
      <link href="/2021/08/05/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-025%20%E6%AD%A3%E6%95%B4%E6%95%B0A+B/"/>
      <url>/2021/08/05/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-025%20%E6%AD%A3%E6%95%B4%E6%95%B0A+B/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA团队天梯赛║L1-025-正整数A-B"><a href="#PTA团队天梯赛║L1-025-正整数A-B" class="headerlink" title="PTA团队天梯赛║L1-025 正整数A+B"></a>PTA团队天梯赛║L1-025 <strong>正整数A+B</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>题的目标很简单，就是求两个正整数<code>A</code>和<code>B</code>的和，其中<code>A</code>和<code>B</code>都在区间[1,1000]。稍微有点麻烦的是，输入并不保证是两个正整数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行给出<code>A</code>和<code>B</code>，其间以空格分开。问题是<code>A</code>和<code>B</code>不一定是满足要求的正整数，有时候可能是超出范围的数字、负数、带小数点的实数、甚至是一堆乱码。</p><p>注意：我们把输入中出现的第1个空格认为是<code>A</code>和<code>B</code>的分隔。题目保证至少存在一个空格，并且<code>B</code>不是一个空字符串。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果输入的确是两个正整数，则按格式<code>A + B = 和</code>输出。如果某个输入不合要求，则在相应位置输出<code>?</code>，显然此时和也是<code>?</code>。</p><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123 456</span><br></pre></td></tr></table></figure><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123 + 456 = 579</span><br></pre></td></tr></table></figure><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22. 18</span><br></pre></td></tr></table></figure><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? + 18 = ?</span><br></pre></td></tr></table></figure><h3 id="输入样例3："><a href="#输入样例3：" class="headerlink" title="输入样例3："></a>输入样例3：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-100 blabla bla...33</span><br></pre></td></tr></table></figure><h3 id="输出样例3："><a href="#输出样例3：" class="headerlink" title="输出样例3："></a>输出样例3：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? + ? = ?</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>思路 v1.0（未能完全通过测试点）</p><p>创建一个函数 <em>isint()</em> ，用于判断输入的是否为正整数，逐个字符判断是否为 <code>0~9</code> 之间的字符，一旦有一个字符不符合，返回值为0，否则返回值为1。在主函数中，将 <em>isint()</em> 的返回值赋给flag，在输出时，若flag为0则输出 <code>?</code> ，结果也输出 <code>?</code> 。</p><hr><p>更新思路 v2.0，做完 L1-064 估值一亿的 AI 核心代码后，利用正则表达式重新完善该题。</p><p>题目有坑注意题目中<code>我们把输入中出现的第1个空格认为是</code>A<code>和</code>B<code>的分隔。题目保证至少存在一个空格，并且</code>B<code>不是一个空字符串。</code>的表述，A 串可为空串，并且B 串中可能出现多个空格的情况。因此需要找到输入的第一个空格将其分割为两个字符串。</p><p>利用 getline() 函数输入字符串，不能用 cin 会发生吞空格情况，遍历字符串，找到第一个空格所在下标，然后用substr() 函数切割成两个字符串检验。</p><p>检验其是否是[1,1000]的正整数，利用正则表达式将输入的字符串分四种情况分开讨论：</p><ol><li>一位数是可以是 1~9 ：<code>/^[1-9]/</code></li><li>两位数和三位数可以是 10~999：<code>/^[1-9][0-9]&#123;1,2&#125;/</code></li><li>最后是四位数的情况 1000：<code>/1000/</code></li></ol><p>利用 regex_match() 判断输入的格式是否正确，利用变量 flag 作为标志，若正确输出原值，不正确则输出 “?”。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.0 得分11分 测试点1、3未通过</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isint</span><span class="params">(string s)</span> <span class="comment">//判断是否为整数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&lt;<span class="string">&#x27;0&#x27;</span> || s[i]&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inrange</span><span class="params">(string s)</span>   <span class="comment">//判断是否在取值范围内</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>()) &lt; <span class="number">1</span> || <span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>()) &gt; <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">bool</span> flag1 = <span class="built_in">isint</span>(a);</span><br><span class="line">    <span class="keyword">bool</span> flag2 = <span class="built_in">isint</span>(b);</span><br><span class="line">    flag1 = <span class="built_in">inrange</span>(a);</span><br><span class="line">    flag2 = <span class="built_in">inrange</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(flag1) cout &lt;&lt; a;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;?&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; + &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag2) cout &lt;&lt; b;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;?&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; = &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag1 &amp;&amp; flag2) cout &lt;&lt; <span class="built_in">atoi</span>(a.<span class="built_in">c_str</span>())+<span class="built_in">atoi</span>(b.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;?&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v2.0 受 L1-064 的启发，使用正则表达式 AC 本题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;(^[1-9]|[1-9][0-9]&#123;1,2&#125;|1000)&quot;</span>)</span></span>;</span><br><span class="line">    string s, a, b;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">// 第一个空格的下标</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)  <span class="comment">// 找到字符串第一个空格的下标，分割两个字符串</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a = s.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">    b = s.<span class="built_in">substr</span>(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag1 = <span class="number">0</span>, flag2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">regex_match</span>(a,pattern))  flag1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">regex_match</span>(b,pattern))  flag2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag1)</span><br><span class="line">        cout &lt;&lt; a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;?&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; + &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag2)</span><br><span class="line">        cout &lt;&lt; b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;?&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; = &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag1&amp;flag2)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">stoi</span>(a)+<span class="built_in">stoi</span>(b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;?&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>这道题目坑稍微有点多，测试点比较刁钻，注意审题的输入情况，对于字符串的输入空格控制比较严苛。利用 getline() 函数输入字符串，不能用 cin 会发生吞空格情况。使用正则表达式处理字符串匹配问题十分方便。</p><hr><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-064 估值一亿的AI核心代码</title>
      <link href="/2021/08/05/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-064%20%E4%BC%B0%E5%80%BC%E4%B8%80%E4%BA%BF%E7%9A%84AI%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/"/>
      <url>/2021/08/05/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-064%20%E4%BC%B0%E5%80%BC%E4%B8%80%E4%BA%BF%E7%9A%84AI%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA团队天梯赛║L1-064-估值一亿的AI核心代码"><a href="#PTA团队天梯赛║L1-064-估值一亿的AI核心代码" class="headerlink" title="PTA团队天梯赛║L1-064 估值一亿的AI核心代码"></a>PTA团队天梯赛║L1-0<strong>64 估值一亿的AI核心代码</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>本题要求你实现一个稍微更值钱一点的 AI 英文问答程序，规则是：</p><ul><li>无论用户说什么，首先把对方说的话在一行中原样打印出来；</li><li>消除原文中多余空格：把相邻单词间的多个空格换成 1 个空格，把行首尾的空格全部删掉，把标点符号前面的空格删掉；</li><li>把原文中所有大写英文字母变成小写，除了 <code>I</code>；</li><li>把原文中所有独立的 <code>can you</code>、<code>could you</code> 对应地换成 <code>I can</code>、<code>I could</code>—— 这里“独立”是指被空格或标点符号分隔开的单词；</li><li>把原文中所有独立的 <code>I</code> 和 <code>me</code> 换成 <code>you</code>；</li><li>把原文中所有的问号 <code>?</code> 换成惊叹号 <code>!</code>；</li><li>在一行中输出替换后的句子作为 AI 的回答。</li></ul><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在第一行给出不超过 10 的正整数 N，随后 N 行，每行给出一句不超过 1000 个字符的、以回车结尾的用户的对话，对话为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按题面要求输出，每个 AI 的回答前要加上 <code>AI:</code> 和一个空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">Hello ?</span><br><span class="line"> Good to chat   with you</span><br><span class="line">can   you speak Chinese?</span><br><span class="line">Really?</span><br><span class="line">Could you show me 5</span><br><span class="line">What Is this prime? I,don &#x27;t know</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello ?</span><br><span class="line">AI: hello!</span><br><span class="line"> Good to chat   with you</span><br><span class="line">AI: good to chat with you</span><br><span class="line">can   you speak Chinese?</span><br><span class="line">AI: I can speak chinese!</span><br><span class="line">Really?</span><br><span class="line">AI: really!</span><br><span class="line">Could you show me 5</span><br><span class="line">AI: I could show you 5</span><br><span class="line">What Is this prime? I,don &#x27;t know</span><br><span class="line">AI: what Is this prime! you,don&#x27;t know</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>本题需要大量的匹配字符串内容，由此可以想到利用正则表达式的匹配来实现匹配相应字符串内容并完成替换的功能，C++中提供了封装的 regex_replace() 函数，可以很好的完成该功能，接下来要做的就是如何合适地匹配以及替换来达到题目要求。</p><ol><li>首先消除字符串中的多余空格，利用 <code>/\s+/</code> 匹配多个空白字符，将其替换为单一空格 ‘ ‘。</li><li>接着消除行首、行尾以及标点符号前的空格，<code>/^\s+|\s$|\s+(?=\W)/</code>，’^’表示行首，’$’表示行尾，’\W’表示非字母、数字、下划线的字符。</li><li>将字符串中的所有 ‘I’ 暂时替换为 “mark”，防止与后续转换 “can you” 时产生的 ‘I’ 混淆，<code>/\bI\b/</code> ,‘\b’ 是匹配单词的边界。</li><li>接着将所有非 ’I‘ 的大写字母转换为小写字母。这里利用 string 的 tolower() 方法遍历字符串。</li><li>然后匹配字符串中的 “can you” 和 “could you” ，<code>/\bcan you\b/</code> 和 <code>/\bcould you\b/</code> ,替换为 “ I can” 和 ”I could“。</li><li>将原句中的 “I” 即现在的 “mark” 和 “me”，<code>/\bmark\b|\bme\b/</code>,转换为 “you” 。</li><li>最后将 “?” 替换为 “!” 。</li></ol><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin,s);</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        s = <span class="built_in">regex_replace</span>(s, <span class="built_in">regex</span>(<span class="string">R&quot;(\s+)&quot;</span>), <span class="string">&quot; &quot;</span>);</span><br><span class="line">        s = <span class="built_in">regex_replace</span>(s, <span class="built_in">regex</span>(<span class="string">R&quot;(^\s+|\s$|\s+(?=\W))&quot;</span>), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        s = <span class="built_in">regex_replace</span>(s, <span class="built_in">regex</span>(<span class="string">R&quot;(\bI\b)&quot;</span>), <span class="string">&quot;mark&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">                s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="built_in">regex_replace</span>(s, <span class="built_in">regex</span>(<span class="string">R&quot;(\bcan you\b)&quot;</span>), <span class="string">&quot;I can&quot;</span>);</span><br><span class="line">        s = <span class="built_in">regex_replace</span>(s, <span class="built_in">regex</span>(<span class="string">R&quot;(\bcould you\b)&quot;</span>), <span class="string">&quot;I could&quot;</span>);</span><br><span class="line">        s = <span class="built_in">regex_replace</span>(s, <span class="built_in">regex</span>(<span class="string">R&quot;(\bmark\b|\bme\b)&quot;</span>), <span class="string">&quot;you&quot;</span>);</span><br><span class="line">        s = <span class="built_in">regex_replace</span>(s, <span class="built_in">regex</span>(<span class="string">R&quot;(\?)&quot;</span>), <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;AI: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>本题使用到了正则表达式，要对于正则表达式的语法熟悉，并且会调用 C++ 中的 regex 相关方法，一开始踩了坑，在调用 regex_replace()函数时对于其参数的正确格式没有掌握，导致一直报错，以下为 <a href="https://blog.csdn.net/qq_34802416/article/details/79307102?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=2">C++ 中 regex 方法的使用的相关资料</a>、<a href="https://www.runoob.com/regexp/regexp-metachar.html">正则表达式基本语法</a>。</p><p>同时，通过做本题，对于之前卡壳无法 AC 的 L1-025 <strong>正整数A+B</strong> ，也尝试使用正则表达式的方法解题。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-072 刮刮彩票</title>
      <link href="/2021/02/13/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-072%20%E5%88%AE%E5%88%AE%E5%BD%A9%E7%A5%A8/"/>
      <url>/2021/02/13/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-072%20%E5%88%AE%E5%88%AE%E5%BD%A9%E7%A5%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-072-刮刮彩票"><a href="#PTA-团队天梯赛║L1-072-刮刮彩票" class="headerlink" title="PTA 团队天梯赛║L1-072 刮刮彩票"></a>PTA 团队天梯赛║L1-072 刮刮彩票</h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>刮刮彩票”是一款网络游戏里面的一个小游戏。如图所示：<img src="https://img-blog.csdnimg.cn/img_convert/19b8b397c526b24af2ceb59c93e0c9b4.png" alt="-362960_55cb6a89bf693.png"></p><p>每次游戏玩家会拿到一张彩票，上面会有 9 个数字，分别为数字 1 到数字 9，数字各不重复，并以 3×3 的“九宫格”形式排布在彩票上。</p><p>在游戏开始时能看见一个位置上的数字，其他位置上的数字均不可见。你可以选择三个位置的数字刮开，这样玩家就能看见四个位置上的数字了。最后玩家再从 3 横、3 竖、2 斜共 8 个方向中挑选一个方向，方向上三个数字的和可根据下列表格进行兑奖，获得对应数额的金币。</p><table><thead><tr><th>数字合计</th><th>获得金币</th><th>数字合计</th><th>获得金币</th></tr></thead><tbody><tr><td>6</td><td>10,000</td><td>16</td><td>72</td></tr><tr><td>7</td><td>36</td><td>17</td><td>180</td></tr><tr><td>8</td><td>720</td><td>18</td><td>119</td></tr><tr><td>9</td><td>360</td><td>19</td><td>36</td></tr><tr><td>10</td><td>80</td><td>20</td><td>306</td></tr><tr><td>11</td><td>252</td><td>21</td><td>1,080</td></tr><tr><td>12</td><td>108</td><td>22</td><td>144</td></tr><tr><td>13</td><td>72</td><td>23</td><td>1,800</td></tr><tr><td>14</td><td>54</td><td>24</td><td>3,600</td></tr><tr><td>15</td><td>180</td><td></td><td></td></tr></tbody></table><p>现在请你写出一个模拟程序，模拟玩家的游戏过程。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一部分给出一张合法的彩票，即用 3 行 3 列给出 0 至 9 的数字。<strong>0 表示的是这个位置上的数字初始时就能看见了</strong>，而不是彩票上的数字为 0。</p><p>第二部给出玩家刮开的三个位置，分为三行，每行按格式 <code>x y</code> 给出玩家刮开的位置的行号和列号（题目中定义左上角的位置为第 1 行、第 1 列。）。数据保证玩家不会重复刮开已刮开的数字。</p><p>最后一部分给出玩家选择的方向，即一个整数： 1 至 3 表示选择横向的第一行、第二行、第三行，4 至 6 表示纵向的第一列、第二列、第三列，7、8 分别表示左上到右下的主对角线和右上到左下的副对角线。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对于每一个刮开的操作，在一行中输出玩家能看到的数字。最后对于选择的方向，在一行中输出玩家获得的金币数量。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 0</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">180</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>用一二维数组存放彩票的九宫格数字，因为输入时有一个 ‘0’ 代表初始可以看到的位置，但是其真实的数值并不为 0，因此可以用 sum 求出输入的所有数字之和，最后用 45-sum 的值就是 ‘0’ 所在位置的数值。之后根据输入执行相应的输出与求和操作，最后用一个数组存放对应的金币值，下标为对应的数字和。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">                y = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[x][y] = <span class="number">45</span> - sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        cout &lt;&lt; a[x][y] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">            sum += a[n][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">            sum += a[i][n<span class="number">-3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">            sum += a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">            sum += a[i][<span class="number">4</span>-i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gold[<span class="number">30</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10000</span>,<span class="number">36</span>,<span class="number">720</span>,<span class="number">360</span>,<span class="number">80</span>,<span class="number">252</span>,<span class="number">108</span>,<span class="number">72</span>,<span class="number">54</span>,<span class="number">180</span>,<span class="number">72</span>,<span class="number">180</span>,<span class="number">119</span>,<span class="number">36</span>,<span class="number">306</span>,<span class="number">1080</span>,<span class="number">144</span>,<span class="number">1800</span>,<span class="number">3600</span>&#125;;</span><br><span class="line">    cout &lt;&lt; gold[sum] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>这道题重点是理解题意，起初没有弄清楚输入的 ‘0’ 的含义，导致一直无法输出正确答案。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L2-003 月饼</title>
      <link href="/2021/02/13/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L2-003%20%E6%9C%88%E9%A5%BC/"/>
      <url>/2021/02/13/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L2-003%20%E6%9C%88%E9%A5%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L2-003-月饼"><a href="#PTA-团队天梯赛║L2-003-月饼" class="headerlink" title="PTA 团队天梯赛║L2-003 月饼"></a>PTA 团队天梯赛║L2-003 月饼</h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p><p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 <em>N</em> 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 <em>D</em> 表示市场最大需求量。随后一行给出 <em>N</em> 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 <em>N</em> 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 20</span><br><span class="line">18 15 10</span><br><span class="line">75 72 45</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">94.50</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>本题要想得到最大利润，一定要先卖单价高的月饼，因此创建一个月饼的结构体，存储其库存，总售价以及单价，根据输入的库存及总售价计算出单价。利用 <em>sort()</em> 函数按照各类月饼的单价降序排序，最后根据市场的最大需求从前向后遍历月饼数组，计算收益。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mooncake</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> stock;  <span class="comment">//库存</span></span><br><span class="line">    <span class="keyword">float</span> totalsale;  <span class="comment">//总售价</span></span><br><span class="line">    <span class="keyword">float</span> price;  <span class="comment">//单价</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(mooncake m1, mooncake m2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m1.price &gt; m2.price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> demand;</span><br><span class="line">    cin &gt;&gt; demand;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mooncake</span> <span class="title">mc</span>[<span class="title">n</span>];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; mc[i].stock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; mc[i].totalsale;</span><br><span class="line">        mc[i].price = mc[i].totalsale / mc[i].stock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(mc,mc+n,cmp);</span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mc[i].stock &lt;= demand) &#123;</span><br><span class="line">            sum += mc[i].totalsale;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += mc[i].price * demand;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        demand -= mc[i].stock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,sum);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>C++中的 <em>sort()</em> 函数十分好用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="built_in">sort</span>(start,end,cmp)</span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line">（<span class="number">1</span>）start 表示要排序数组的起始地址；</span><br><span class="line">（<span class="number">2</span>）end 表示数组结束地址的下一位；</span><br><span class="line">（<span class="number">3</span>）cmp 用于规定排序的方法，可不填，默认升序。</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例一  sort 函数没有第三个参数，实现的是从小到大（升序）排列：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sort</span>(a,a+<span class="number">10</span>);<span class="comment">//指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例二 加入一个比较函数 compare()，实现从大到小（降序）排列：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;endl;  </span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">10</span>,compare);<span class="comment">//在这里就不需要对 compare 函数传入参数了   </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例三 有一个 node 类型的数组 node arr[100]，想对它进行排序：先按 a 值升序排列，如果 a 值相同，再按 b 值降序排列，如果 b 还相同，就按 c 降序排列。就可以写一个比较函数：</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="keyword">if</span>(x.a!=y.a) <span class="keyword">return</span> x.a&lt;y.a;    </span><br><span class="line"><span class="keyword">if</span>(x.b!=y.b) <span class="keyword">return</span> x.b&gt;y.b;    </span><br><span class="line"><span class="keyword">return</span> x.c&gt;y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-071 前世档案</title>
      <link href="/2021/02/12/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-071%20%E5%89%8D%E4%B8%96%E6%A1%A3%E6%A1%88/"/>
      <url>/2021/02/12/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-071%20%E5%89%8D%E4%B8%96%E6%A1%A3%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-071-前世档案"><a href="#PTA-团队天梯赛║L1-071-前世档案" class="headerlink" title="PTA 团队天梯赛║L1-071 前世档案"></a>PTA 团队天梯赛║L1-071 前世档案</h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>网络世界中时常会遇到这类滑稽的算命小程序，实现原理很简单，随便设计几个问题，根据玩家对每个问题的回答选择一条判断树中的路径（如下图所示），结论就是路径终点对应的那个结点。<img src="https://img-blog.csdnimg.cn/img_convert/d0cc6b8b9b54174feb6f0d2f2a0e239a.png" alt="path.jpg"></p><p>现在我们把结论从左到右顺序编号，编号从 1 开始。这里假设回答都是简单的“是”或“否”，又假设回答“是”对应向左的路径，回答“否”对应向右的路径。给定玩家的一系列回答，请你返回其得到的结论的编号。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数：<em>N</em>（≤30）为玩家做一次测试要回答的问题数量；<em>M</em>（≤100）为玩家人数。</p><p>随后 <em>M</em> 行，每行顺次给出玩家的 <em>N</em> 个回答。这里用 <code>y</code> 代表“是”，用 <code>n</code> 代表“否”。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个玩家，在一行中输出其对应的结论的编号。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br><span class="line">yny</span><br><span class="line">nyy</span><br><span class="line">nyn</span><br><span class="line">yyn</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>转化题目为找数学规律的题目，结论编号可通过每次问题的选择计算得出，令起始的结论编号为 1，遇到 ‘y’ 则结论编号不做变化，若遇到 ‘n’，则将结论编号加 2 <sup>n-j</sup> ( j ) 为第几个问题。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cld = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line">                cld += <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">                cld += <span class="built_in">pow</span>(<span class="number">2</span>,n-j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cld &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>根据题目要求找到规律，题目就很好解决了。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-059 敲笨种</title>
      <link href="/2021/02/10/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-059%20%E6%95%B2%E7%AC%A8%E7%A7%8D/"/>
      <url>/2021/02/10/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-059%20%E6%95%B2%E7%AC%A8%E7%A7%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-059-敲笨种"><a href="#PTA-团队天梯赛║L1-059-敲笨种" class="headerlink" title="PTA 团队天梯赛║L1-059 敲笨种"></a>PTA 团队天梯赛║L1-0<strong>59 敲笨种</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>微博上有个自称“大笨钟 V”的家伙，每天敲钟催促码农们爱惜身体早点睡觉。为了增加敲钟的趣味性，还会糟改几句古诗词。其糟改的方法为：去网上搜寻压“ong”韵的古诗词，把句尾的三个字换成“敲笨钟”。例如唐代诗人李贺有名句曰：“寻章摘句老雕虫，晓月当帘挂玉弓”，其中“虫”（chong）和“弓”（gong）都压了“ong”韵。于是这句诗就被糟改为“寻章摘句老雕虫，晓月当帘敲笨钟”。</p><p>现在给你一大堆古诗词句，要求你写个程序自动将压“ong”韵的句子糟改成“敲笨钟”。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在第一行给出一个不超过 20 的正整数 N。随后 N 行，每行用汉语拼音给出一句古诗词，分上下两半句，用逗号 <code>,</code> 分隔，句号 <code>.</code> 结尾。相邻两字的拼音之间用一个空格分隔。题目保证每个字的拼音不超过 6 个字符，每行字符的总长度不超过 100，并且下半句诗至少有 3 个字。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每一行诗句，判断其是否压“ong”韵。即上下两句末尾的字都是“ong”结尾。如果是压此韵的，就按题面方法糟改之后输出，输出格式同输入；否则输出 <code>Skipped</code>，即跳过此句。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">xun zhang zhai ju lao diao chong, xiao yue dang lian gua yu gong.</span><br><span class="line">tian sheng wo cai bi you yong, qian jin san jin huan fu lai.</span><br><span class="line">xue zhui rou zhi leng wei rong, an xiao chen jing shu wei long.</span><br><span class="line">zuo ye xing chen zuo ye feng, hua lou xi pan gui tang dong.</span><br><span class="line">ren xian gui hua luo, ye jing chun shan kong.</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xun zhang zhai ju lao diao chong, xiao yue dang lian qiao ben zhong.</span><br><span class="line">Skipped</span><br><span class="line">xue zhui rou zhi leng wei rong, an xiao chen jing qiao ben zhong.</span><br><span class="line">Skipped</span><br><span class="line">Skipped</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>检查每一个字符，遇到 <code>&#39;,&#39;</code> 和 <code>&#39;.&#39;</code> 时，向前回溯三位判断是否压韵，若不符合则将 flag 置为 0 ，并 break；若都符合，则在 <code>&#39;.&#39;</code> 向前回溯三个空格（三个单词），利用 string 里的 <em>replace()</em> 方法替换字符串内容。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin,s);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s.<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(s[j<span class="number">-3</span>] == <span class="string">&#x27;o&#x27;</span> &amp;&amp; s[j<span class="number">-2</span>] == <span class="string">&#x27;n&#x27;</span> &amp;&amp; s[j<span class="number">-1</span>] == <span class="string">&#x27;g&#x27;</span>)) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(s[j<span class="number">-3</span>] == <span class="string">&#x27;o&#x27;</span> &amp;&amp; s[j<span class="number">-2</span>] == <span class="string">&#x27;n&#x27;</span> &amp;&amp; s[j<span class="number">-1</span>] == <span class="string">&#x27;g&#x27;</span>)) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> m = j;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">3</span>; m--) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(s[m] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                            k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    s.<span class="built_in">replace</span>(m+<span class="number">2</span>,j-m,<span class="string">&quot;qiao ben zhong.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)   cout &lt;&lt; <span class="string">&quot;Skipped&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>string 里的 <em>replace()</em> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;<span class="comment">//应用一：string &amp;replace(size_t pos,size_t len,const &amp;str) 实现</span></span><br><span class="line">string s = <span class="string">&quot;0123456&quot;</span>;</span><br><span class="line">string str = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">2</span>, <span class="number">2</span>, str);<span class="comment">//在 s 的 pos=2 位置往后 len=2 字符（“23”）替换为&quot;ABCD&quot;</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="comment">//应用二：string &amp;replace(size_t pos, size_tlen, const string &amp;str, size_t subpos, size_t sublen)</span></span><br><span class="line"><span class="comment">//被替换位置 (pos 往后 len 长度)，替换位置（subpos 往后 sublen 长度）</span></span><br><span class="line">string s = <span class="string">&quot;0123456&quot;</span>;</span><br><span class="line">string str = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">2</span>, <span class="number">2</span>, str, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//s 在 s 的 pos=2 位置往后 len=2 个字符（“23”）替换为“BC”(str 中 subpos=1 往后两个位置)</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#123;<span class="comment">//应用三:string &amp;replace(size_t pos,size_t len,const char* s)  插入 C 串</span></span><br><span class="line">string s = <span class="string">&quot;0123456&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">2</span>, <span class="number">2</span>, str, <span class="number">1</span>, <span class="number">2</span>);s 在 s 的 pos=<span class="number">2</span> 位置往后 len=<span class="number">2</span> 个字符（“<span class="number">23</span>”）替换为“BC”(str 中 subpos=<span class="number">1</span> 往后两个位置)</span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="comment">//应用四：string &amp;replace（size_t pos,size_t len,const char* cch,size_t n）插入 C 串前 n 个字符</span></span><br><span class="line">string s = <span class="string">&quot;0123456&quot;</span>;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="string">&quot;ABCD&quot;</span>, <span class="number">2</span>);<span class="comment">//在指定位置（pos=2,len=2）插入“ABCD”前两个字符</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">//应用五：string &amp;replace(size_t pos, size_t len, size_t n, char c)</span></span><br><span class="line">string s = <span class="string">&quot;0123456&quot;</span>;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="string">&#x27;A&#x27;</span>);<span class="comment">//在指定位置（pos=2,len=2）插入 5 个 &#x27;A&#x27;;</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="comment">//应用六：（只举一例，其他与 size_t 操作类似）</span></span><br><span class="line"><span class="comment">//string &amp;replace(const_iterator first,const_iterator last,const string&amp;str)</span></span><br><span class="line"><span class="comment">//string &amp;replace(const_iterator first,const_iterator last,const char* cch)</span></span><br><span class="line"><span class="comment">//string &amp;replace(const_iterator first,const_iterator last,const char* cch,size_t n)</span></span><br><span class="line"><span class="comment">//string &amp;replace(const_iterator first,const_iterator last,size_t n,char c)</span></span><br><span class="line"><span class="comment">//需要注意的是迭代器操作中第二个参数不再是 len 而是位置</span></span><br><span class="line">string s = <span class="string">&quot;0123456&quot;</span>;</span><br><span class="line">string str = <span class="string">&quot;ABCD&quot;</span>;  </span><br><span class="line">string::iterator it= s.<span class="built_in">begin</span>();</span><br><span class="line">s.<span class="built_in">replace</span>(it, it+<span class="number">2</span>, str);<span class="comment">//s 在 s 的 pos=2 位置往后 len=2 个字符（“23”）替换为“BC”(str 中 subpos=1 往后两个位置)</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190326083320232.png" alt="在这里插入图片描述 "></p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-056 猜数字</title>
      <link href="/2021/02/08/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-056%20%E7%8C%9C%E6%95%B0%E5%AD%97/"/>
      <url>/2021/02/08/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-056%20%E7%8C%9C%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-056-猜数字"><a href="#PTA-团队天梯赛║L1-056-猜数字" class="headerlink" title="PTA 团队天梯赛║L1-056 猜数字"></a>PTA 团队天梯赛║L1-0<strong>56 猜数字</strong></h1><h2 id="一、解题思路"><a href="#一、解题思路" class="headerlink" title="一、解题思路"></a>一、解题思路</h2><p>一群人坐在一起，每人猜一个 100 以内的数，谁的数字最接近大家平均数的一半就赢。本题就要求你找出其中的赢家。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数 N（≤104）。随后 N 行，每行给出一个玩家的名字（由不超过 8 个英文字母组成的字符串）和其猜的正整数（≤ 100）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中顺序输出：大家平均数的一半（只输出整数部分）、赢家的名字，其间以空格分隔。题目保证赢家是唯一的。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">Bob 35</span><br><span class="line">Amy 28</span><br><span class="line">James 98</span><br><span class="line">Alice 11</span><br><span class="line">Jack 45</span><br><span class="line">Smith 33</span><br><span class="line">Chris 62</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22 Amy</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>用一个结构体存储每个人的名字与数字，然后用 min 存储结构体数组中与平均数一半差值最小的下标，通过取绝对值比较差值的方法更新 min ，最后输出结果即可。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hm</span> &#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;hm&gt; v;</span><br><span class="line">    <span class="keyword">int</span> n, sum = <span class="number">0</span>;</span><br><span class="line">    hm temp;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; temp.name &gt;&gt; temp.num;</span><br><span class="line">        v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        sum += temp.num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> ave = sum / n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(v[i].num - ave) &lt; <span class="built_in">abs</span>(v[min].num - ave)) &#123;</span><br><span class="line">            min = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.0f %s\n&quot;</span>,ave,v[min].name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>使用 printf() 输出时，由于 C 语言中 string 类的问题，需要使用函数 c_str() 将 C++ 的 string 类型字符串转化为 C 语言中的字符串类型。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-058 6翻了</title>
      <link href="/2021/02/08/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-058%206%E7%BF%BB%E4%BA%86/"/>
      <url>/2021/02/08/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-058%206%E7%BF%BB%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-058-6-翻了"><a href="#PTA-团队天梯赛║L1-058-6-翻了" class="headerlink" title="PTA 团队天梯赛║L1-058 6 翻了"></a>PTA 团队天梯赛║L1-0<strong>58 6 翻了</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>666”是一种网络用语，大概是表示某人很厉害、我们很佩服的意思。最近又衍生出另一个数字“9”，意思是“6 翻了”，实在太厉害的意思。如果你以为这就是厉害的最高境界，那就错啦 —— 目前的最高境界是数字“27”，因为这是 3 个 “9”！</p><p>本题就请你编写程序，将那些过时的、只会用一连串“6666……6”表达仰慕的句子，翻译成最新的高级表达。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一句话，即一个非空字符串，由不超过 1000 个英文字母、数字和空格组成，以回车结束。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>从左到右扫描输入的句子：如果句子中有超过 3 个连续的 6，则将这串连续的 6 替换成 9；但如果有超过 9 个连续的 6，则将这串连续的 6 替换成 27。其他内容不受影响，原样输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it is so 666 really 6666 what else can I say 6666666666</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it is so 666 really 9 what else can I say 27</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>设置一个 cnt 用来记录遍历字符串时遇到的 ‘6’ ，若遇到 ‘6’ ，则 cnt++ ；否则，判断 <code>0&lt;cnt&lt;4</code> 按照 cnt 大小输出 ‘6’ ，<code>3&lt;cnt&lt;10</code> 则输出 ’9‘ ，<code>cnt&gt;9</code> 则输出 ”27“（以上三步操作结束后均需将 cnt 归零），输出本位上的字符。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;6&#x27;</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; <span class="number">9</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;27&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt &gt; <span class="number">3</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(cnt--)</span><br><span class="line">                    cout &lt;&lt; <span class="string">&#x27;6&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; <span class="number">9</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;27&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt &gt; <span class="number">3</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt--)</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;6&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>如果 6 出现在了字符串尾会出现读取不到的错误，分析可能是读到字符串结束符号 <code>\0</code> , 所以最后又加了一趟对 cnt 是否为零的判断，保证结束后 cnt 为 0。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团体天梯赛║L1-049 天梯赛座位分配</title>
      <link href="/2021/02/05/PTA%E5%9B%A2%E4%BD%93%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-049%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D/"/>
      <url>/2021/02/05/PTA%E5%9B%A2%E4%BD%93%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-049%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团体天梯赛║L1-049-天梯赛座位分配"><a href="#PTA-团体天梯赛║L1-049-天梯赛座位分配" class="headerlink" title="PTA 团体天梯赛║L1-049 天梯赛座位分配"></a>PTA 团体天梯赛║<strong>L1-049 天梯赛座位分配</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>天梯赛每年有大量参赛队员，要保证同一所学校的所有队员都不能相邻，分配座位就成为一件比较麻烦的事情。为此我们制定如下策略：假设某赛场有 N 所学校参赛，第 i 所学校有 M[i] 支队伍，每队 10 位参赛选手。令每校选手排成一列纵队，第 i+1 队的选手排在第 i 队选手之后。从第 1 所学校开始，各校的第 1 位队员顺次入座，然后是各校的第 2 位队员…… 以此类推。如果最后只剩下 1 所学校的队伍还没有分配座位，则需要安排他们的队员隔位就坐。本题就要求你编写程序，自动为各校生成队员的座位号，从 1 开始编号。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出参赛的高校数 N （不超过 100 的正整数）；第二行给出 N 个不超过 10 的正整数，其中第 i 个数对应第 i 所高校的参赛队伍数，数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>从第 1 所高校的第 1 支队伍开始，顺次输出队员的座位号。每队占一行，座位号间以 1 个空格分隔，行首尾不得有多余空格。另外，每所高校的第一行按“#X”输出该校的编号 X，从 1 开始。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line">1 4 7 10 13 16 19 22 25 28</span><br><span class="line">31 34 37 40 43 46 49 52 55 58</span><br><span class="line">61 63 65 67 69 71 73 75 77 79</span><br><span class="line">#2</span><br><span class="line">2 5 8 11 14 17 20 23 26 29</span><br><span class="line">32 35 38 41 44 47 50 53 56 59</span><br><span class="line">62 64 66 68 70 72 74 76 78 80</span><br><span class="line">82 84 86 88 90 92 94 96 98 100</span><br><span class="line">#3</span><br><span class="line">3 6 9 12 15 18 21 24 27 30</span><br><span class="line">33 36 39 42 45 48 51 54 57 60</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>让每个学校的学生排成一排，为每个座位安排学生。num[i] 是第 i 个学校的队伍数，id_school[i] 是第 i 个座位上坐的是哪个学校的学生。</p><p>每把椅子依次从学生面前走过，如果这个学校还有学生未被安排，则安排座位给学生，安排方案如下：</p><p>如果此前一个座位的学生不是本校的，则将该作为安排给此校学生，并标记这把椅子被该校学生坐了；如果此前的一个座位是本校学生，则将此学生安排在后一个座位上，并标记后一个座位被该校学生坐了。</p><p>设置 flag 标志，如果所有学生都被安排，则可退出。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, cnt = <span class="number">1</span>, num[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;, id_school[<span class="number">10001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">v</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i].<span class="built_in">size</span>() &lt; num[i]*<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(id_school[cnt<span class="number">-1</span>] != i) &#123;</span><br><span class="line">                    id_school[cnt] = i;</span><br><span class="line">                    v[i].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    id_school[cnt+<span class="number">1</span>] = i;</span><br><span class="line">                    v[i].<span class="built_in">push_back</span>(cnt+<span class="number">1</span>);</span><br><span class="line">                    cnt+=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;#%d\n&quot;</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;v[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j !=<span class="number">0</span> &amp;&amp; j % <span class="number">10</span> != <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(j !=<span class="number">0</span> &amp;&amp; j % <span class="number">10</span> == <span class="number">0</span>) cout &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; v[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>解题思路参考柳诺大神的想法，以后还要好好琢磨再看这道题目！</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团体天梯赛║L1-054 福到了</title>
      <link href="/2021/02/05/PTA%E5%9B%A2%E4%BD%93%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-054%20%E7%A6%8F%E5%88%B0%E4%BA%86/"/>
      <url>/2021/02/05/PTA%E5%9B%A2%E4%BD%93%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-054%20%E7%A6%8F%E5%88%B0%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团体天梯赛║L1-054-福到了"><a href="#PTA-团体天梯赛║L1-054-福到了" class="headerlink" title="PTA 团体天梯赛║L1-054 福到了"></a>PTA 团体天梯赛║<strong>L1-054 福到了</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>“福”字倒着贴，寓意“福到”。不论到底算不算民俗，本题且请你编写程序，把各种汉字倒过来输出。这里要处理的每个汉字是由一个 N × N 的网格组成的，网格中的元素或者为字符 <code>@</code> 或者为空格。而倒过来的汉字所用的字符由裁判指定。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出倒过来的汉字所用的字符、以及网格的规模 N （不超过 100 的正整数），其间以 1 个空格分隔；随后 N 行，每行给出 N 个字符，或者为 <code>@</code> 或者为空格。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出倒置的网格，如样例所示。但是，如果这个字正过来倒过去是一样的，就先输出<code>bu yong dao le</code>，然后再用输入指定的字符将其输出。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ 9</span><br><span class="line"> @  @@@@@</span><br><span class="line">@@@  @@@ </span><br><span class="line"> @   @ @ </span><br><span class="line">@@@  @@@ </span><br><span class="line">@@@ @@@@@</span><br><span class="line">@@@ @ @ @</span><br><span class="line">@@@ @@@@@</span><br><span class="line"> @  @ @ @</span><br><span class="line"> @  @@@@@</span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$$$$  $ </span><br><span class="line">$ $ $  $ </span><br><span class="line">$$$$$ $$$</span><br><span class="line">$ $ $ $$$</span><br><span class="line">$$$$$ $$$</span><br><span class="line"> $$$  $$$</span><br><span class="line"> $ $   $ </span><br><span class="line"> $$$  $$$</span><br><span class="line">$$$$$  $ </span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp; 3</span><br><span class="line">@@@</span><br><span class="line"> @ </span><br><span class="line">@@@</span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bu yong dao le</span><br><span class="line">&amp;&amp;&amp;</span><br><span class="line"> &amp; </span><br><span class="line">&amp;&amp;&amp;</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>设置 flag 来判断是否倒过来和原来相同，然后输出时倒序输出即可。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin,v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i][j] != v[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j])</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bu yong dao le&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">                cout &lt;&lt; c;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>注意在输入 c 和 n 后，要加一个 <em>getchar()</em> 来吸收掉换行，否则程序输出会出错。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-046 整除光棍</title>
      <link href="/2021/02/04/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-046%20%E6%95%B4%E9%99%A4%E5%85%89%E6%A3%8D/"/>
      <url>/2021/02/04/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-046%20%E6%95%B4%E9%99%A4%E5%85%89%E6%A3%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-046-整除光棍"><a href="#PTA-团队天梯赛║L1-046-整除光棍" class="headerlink" title="PTA 团队天梯赛║L1-046 整除光棍"></a>PTA 团队天梯赛║L1-046 <strong>整除光棍</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由 1 组成的数字，比如 1、11、111、1111 等。传说任何一个光棍都能被一个不以 5 结尾的奇数整除。比如，111111 就可以被 13 整除。 现在，你的程序要读入一个整数<code>x</code>，这个整数一定是奇数并且不以 5 结尾。然后，经过计算，输出两个数字：第一个数字<code>s</code>，表示<code>x</code>乘以<code>s</code>是一个光棍，第二个数字<code>n</code>是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。</p><p>提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除<code>x</code>为止。但难点在于，<code>s</code>可能是个非常大的数 —— 比如，程序输入 31，那么就输出 3584229390681 和 15，因为 31 乘以 3584229390681 的结果是 111111111111111，一共 15 个 1。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个不以 5 结尾的正奇数<code>x</code>（&lt;1000）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出相应的最小的<code>s</code>和<code>n</code>，其间以 1 个空格分隔。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">31</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3584229390681 15</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>模拟竖式除法的过程，按位进行除法，用字符数组存放除得的数来解决得到的数会很长的问题</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p||m/x)<span class="comment">//p 非 0 或者 m/x 非 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[p++]=<span class="string">&#x27;0&#x27;</span>+m/x;<span class="comment">//除得的数化为字符存储</span></span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">        m=m%x;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[p]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>,a,l);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m=m*<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>注意在字符数组最后一位要赋值 <code>&#39;\n&#39;</code> 标志字符数组结束，否则输出时会出现乱码问题</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-043 阅览室</title>
      <link href="/2021/02/03/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-043%20%E9%98%85%E8%A7%88%E5%AE%A4/"/>
      <url>/2021/02/03/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-043%20%E9%98%85%E8%A7%88%E5%AE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-043-阅览室"><a href="#PTA-团队天梯赛║L1-043-阅览室" class="headerlink" title="PTA 团队天梯赛║L1-043 阅览室"></a>PTA 团队天梯赛║L1-043 <strong>阅览室</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>天梯图书阅览室请你编写一个简单的图书借阅统计程序。当读者借书时，管理员输入书号并按下<code>S</code>键，程序开始计时；当读者还书时，管理员输入书号并按下<code>E</code>键，程序结束计时。书号为不超过 1000 的正整数。当管理员将 0 作为书号输入时，表示一天工作结束，你的程序应输出当天的读者借书次数和平均阅读时间。</p><p>注意：由于线路偶尔会有故障，可能出现不完整的纪录，即只有<code>S</code>没有<code>E</code>，或者只有<code>E</code>没有<code>S</code>的纪录，系统应能自动忽略这种无效纪录。另外，题目保证书号是书的唯一标识，同一本书在任何时间区间内只可能被一位读者借阅。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤10），随后给出<em>N</em>天的纪录。每天的纪录由若干次借阅操作组成，每次操作占一行，格式为：</p><p><code>书号</code>（[1, 1000] 内的整数） <code>键值</code>（<code>S</code>或<code>E</code>） <code>发生时间</code>（<code>hh:mm</code>，其中<code>hh</code>是[0,23] 内的整数，<code>mm</code>是[0, 59] 内整数）</p><p>每一天的纪录保证按时间递增的顺序给出。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每天的纪录，在一行中输出当天的读者借书次数和平均阅读时间（以分钟为单位的精确到个位的整数时间）。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 S 08:10</span><br><span class="line">2 S 08:35</span><br><span class="line">1 E 10:00</span><br><span class="line">2 E 13:16</span><br><span class="line">0 S 17:00</span><br><span class="line">0 S 17:00</span><br><span class="line">3 E 08:10</span><br><span class="line">1 S 08:20</span><br><span class="line">2 S 09:00</span><br><span class="line">1 E 09:20</span><br><span class="line">0 E 17:00</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 196</span><br><span class="line">0 0</span><br><span class="line">1 60</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>因为有可能会有书未被借出就还书的错误情况，而且要记录平均平均阅读时间，因此用一个结构体存储书籍借出情况 <code>flag</code> （0 为未借出，1 为借出），以及借出时间 <code>starttime</code> 。在判断键入时，若书号键入 0 则跳出当日的输入循环，否则判断键值 <code>S</code> 时写入借出时间，借书计数加一；判断键值 <code>E</code> 时，该书号 <code>flag</code> 若为 0 则忽略，若为 1 则将还书时间减去借出时间作为借阅时间加入本日的阅览总时间，并将 <code>flag</code> 置为 0。最后计算平均借阅时间，输出借书计数与平均借阅时间即可。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> flag;  <span class="comment">//0 为未被借出，1 为借出</span></span><br><span class="line">    <span class="keyword">int</span> starttime;  <span class="comment">//借出时间</span></span><br><span class="line">&#125;book;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettime</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h*<span class="number">60</span> + m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Book b[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">double</span> sumtime; <span class="comment">//最后要四舍五入取 double 类型</span></span><br><span class="line">    <span class="keyword">int</span> num, h, m, count;  <span class="comment">//书号，结束时间的时与分，每日的借书数量</span></span><br><span class="line">    <span class="keyword">char</span> c; <span class="comment">//键值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Book)*<span class="number">1001</span>);  <span class="comment">//初始化结构体，新的一天将所有书本状态归零</span></span><br><span class="line">        sumtime = <span class="number">0</span>;    <span class="comment">//新的一天阅览总时间归零</span></span><br><span class="line">        count = <span class="number">0</span>;  <span class="comment">//每日借书数量归零</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %c %d:%d&quot;</span>,&amp;num,&amp;c,&amp;h,&amp;m))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b[num].starttime = <span class="built_in">gettime</span>(h,m);</span><br><span class="line">                b[num].flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(b[num].flag == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sumtime += <span class="built_in">gettime</span>(h,m)-b[num].starttime;</span><br><span class="line">                    b[num].flag = <span class="number">0</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0 0\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> averge = <span class="built_in">round</span>(sumtime/count);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,count,averge);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><ol><li><p><em><strong>void *memset(void *s, int c, size_t n)</strong></em></p><p>memset:作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法。</p><p>一定要记住 如果要把一个 char a[20] 清零, 一定是 memset(a, 0, 20)<br>而不是 memset(a, 20, 0) </p></li><li><p>注意本题容易出现 <strong>浮点错误</strong> ，即有可能除数为 0 ，要注意将这一特殊情况分开讨论。</p></li><li><p>起初部分测试点结果一直差一，是因为整型数据除法计算直接保留整数，为了让结果四舍五入，将数据类型改为 <code>double</code> ，然后使用 <em>round()</em> 函数实现计算结果四舍五入。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-039 古风排版</title>
      <link href="/2021/02/02/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-039%20%E5%8F%A4%E9%A3%8E%E6%8E%92%E7%89%88/"/>
      <url>/2021/02/02/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-039%20%E5%8F%A4%E9%A3%8E%E6%8E%92%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-039-古风排版"><a href="#PTA-团队天梯赛║L1-039-古风排版" class="headerlink" title="PTA 团队天梯赛║L1-039 古风排版"></a>PTA 团队天梯赛║L1-039 <strong>古风排版</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>中国的古人写文字，是从右向左竖向排版的。本题就请你编写程序，把一段文字按古风排版。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（&lt;100），是每一列的字符数。第二行给出一个长度不超过 1000 的非空字符串，以回车结束。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按古风格式排版给定的字符串，每列<em>N</em>个字符（除了最后一列可能不足<em>N</em>个）。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">This is a test case</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asa T</span><br><span class="line">st ih</span><br><span class="line">e tsi</span><br><span class="line"> ce s</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>利用一个二维字符数组存放字符串比较容易操作与理解，输入行数后就可以根据字符串长度确定输出时的列数，然后从最后一列开始输入字符串的每一个字符，直至字符串结束。最后顺序输出二位字符数组即可。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.0 初始化字符数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>][<span class="number">100</span>]=&#123;<span class="string">&#x27; &#x27;</span>&#125;;<span class="comment">//字符数组不可以这样初始化</span></span><br><span class="line">    <span class="keyword">int</span> row, col, k = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; row;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">length</span>()%row == <span class="number">0</span>)</span><br><span class="line">        col = s.<span class="built_in">length</span>() / row;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        col = s.<span class="built_in">length</span>() / row + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=col<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;row; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j][i] = s[k++];</span><br><span class="line">            <span class="keyword">if</span>(k==s.<span class="built_in">length</span>()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>第一版中错误的使用 a[100] [100] = ‘ ‘ 进行初始化字符数组，导致不能通过测试。</p><p>改进后代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v2.0 改进初始化字符数组方式，成功 AC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;<span class="comment">//利用循环挨个为字符数组元素赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)&#123;</span><br><span class="line">            a[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> row, col, k = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; row;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">length</span>()%row == <span class="number">0</span>)</span><br><span class="line">        col = s.<span class="built_in">length</span>() / row;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        col = s.<span class="built_in">length</span>() / row + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=col<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;row; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j][i] = s[k++];</span><br><span class="line">            <span class="keyword">if</span>(k==s.<span class="built_in">length</span>()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-035 情人节</title>
      <link href="/2021/01/25/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-035%20%E6%83%85%E4%BA%BA%E8%8A%82/"/>
      <url>/2021/01/25/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-035%20%E6%83%85%E4%BA%BA%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-035-情人节"><a href="#PTA-团队天梯赛║L1-035-情人节" class="headerlink" title="PTA 团队天梯赛║L1-035 情人节"></a>PTA 团队天梯赛║L1-035 <strong>情人节</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/754ee99ecdc14e2053677edcdb4d0546.png" alt="img"></p><p>以上是朋友圈中一奇葩贴：“2 月 14 情人节了，我决定造福大家。第 2 个赞和第 14 个赞的，我介绍你俩认识…………咱三吃饭…你俩请…”。现给出此贴下点赞的朋友名单，请你找出那两位要请客的倒霉蛋。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入按照点赞的先后顺序给出不知道多少个点赞的人名，每个人名占一行，为不超过 10 个英文字母的非空单词，以回车结束。一个英文句点<code>.</code>标志输入的结束，这个符号不算在点赞名单里。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>根据点赞情况在一行中输出结论：若存在第 2 个人 A 和第 14 个人 B，则输出“A and B are inviting you to dinner…”；若只有 A 没有 B，则输出“A is the only one for you…”；若连 A 都没有，则输出“Momo… No one is for you …”。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GaoXZh</span><br><span class="line">Magi</span><br><span class="line">Einst</span><br><span class="line">Quark</span><br><span class="line">LaoLao</span><br><span class="line">FatMouse</span><br><span class="line">ZhaShen</span><br><span class="line">fantacy</span><br><span class="line">latesum</span><br><span class="line">SenSen</span><br><span class="line">QuanQuan</span><br><span class="line">whatever</span><br><span class="line">whenever</span><br><span class="line">Potaty</span><br><span class="line">hahaha</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Magi and Potaty are inviting you to dinner...</span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LaoLao</span><br><span class="line">FatMouse</span><br><span class="line">whoever</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FatMouse is the only one for you...</span><br></pre></td></tr></table></figure><h3 id="输入样例-3："><a href="#输入样例-3：" class="headerlink" title="输入样例 3："></a>输入样例 3：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LaoLao</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h3 id="输出样例-3："><a href="#输出样例-3：" class="headerlink" title="输出样例 3："></a>输出样例 3：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Momo... No one is for you ...</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>用 while 语句输入字符串，知道判断输入的字符串第一个字符为 <strong>‘.’</strong> 时，break 跳出循环，初始化两个空字符串，在循环中如果有第二和第十四个输入的字符串，就将其分别赋值给这两个空字符串，最后在循环外判断两字符串是否为空，分情况输出结果。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    string s1=<span class="string">&quot; &quot;</span>, s2=<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;.&#x27;</span>)   <span class="keyword">break</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">2</span>)  s1 = s;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">14</span>) s2 = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s1 != <span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s2 != <span class="string">&quot; &quot;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s and %s are inviting you to dinner...\n&quot;</span>,s1.<span class="built_in">c_str</span>(),s2.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is the only one for you...\n&quot;</span>,s1.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Momo... No one is for you ...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>用 <em>printf()</em> 输出字符串时，s 为 <code>string</code> 类型</p><p><strong>语法</strong></p><ul><li>const char *c_str();</li><li>c_str() 函数返回一个指向正规 C 字符串的指针, 内容与本 string 串相同.</li><li>为了与 C 兼容，在 C 中没有 string 类型，故必须通过 string 类对象的成员函数 c_str() 把 string 对象转换成 C 中的字符串样式。</li></ul><p>需要 s.c_str() 才可以正确输出。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-033 出生年</title>
      <link href="/2021/01/25/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-033%20%E5%87%BA%E7%94%9F%E5%B9%B4/"/>
      <url>/2021/01/25/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-033%20%E5%87%BA%E7%94%9F%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-033-出生年"><a href="#PTA-团队天梯赛║L1-033-出生年" class="headerlink" title="PTA 团队天梯赛║L1-033 出生年"></a>PTA 团队天梯赛║L1-033 <strong>出生年</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/9bfc3d1945821cc5f50d46aa57613714.png" alt="355"></p><p>以上是新浪微博中一奇葩贴：“我出生于 1988 年，直到 25 岁才遇到 4 个数字都不相同的年份。”也就是说，直到 2013 年才达到“4 个数字都不相同”的要求。本题请你根据要求，自动填充“我出生于<code>y</code>年，直到<code>x</code>岁才遇到<code>n</code>个数字都不相同的年份”这句话。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出出生年份<code>y</code>和目标年份中不同数字的个数<code>n</code>，其中<code>y</code>在[1, 3000] 之间，<code>n</code>可以是 2、或 3、或 4。注意不足 4 位的年份要在前面补零，例如公元 1 年被认为是 0001 年，有 2 个不同的数字 0 和 1。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>根据输入，输出<code>x</code>和能达到要求的年份。数字间以 1 个空格分隔，行首尾不得有多余空格。年份要按 4 位输出。注意：所谓“<code>n</code>个数字都不相同”是指不同的数字正好是<code>n</code>个。如“2013”被视为满足“4 位数字都不同”的条件，但不被视为满足 2 位或 3 位数字不同的条件。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1988 4</span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 2013</span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0001</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>先将输入的整型转换为字符串，并在不足四位的数前面补零，然后用一个数组 a[10] 存储 0~9 在年份中出现的次数，之后从出生年份循环判断 a 中非零元素个数，若与输入的要求不同数字的个数相同，则输出年龄与该年份；若不同，则年龄与年份自加。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> str, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(str);</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">length</span>()&lt;<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="string">&quot;0&quot;</span> + s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[s[i]-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)    count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count==n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> n, old = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; year &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">judge</span>(year,n))</span><br><span class="line">    &#123;</span><br><span class="line">        old++;</span><br><span class="line">        year++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %04d&quot;</span>,old,year);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>最后要注意控制输出的时候同样年份不足四位的前面要补全 0。</p><p>同时贴上网上一个利用 <code>set</code> 容器实现的方法，更加高效简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span><span class="comment">//set 容器不允许重复 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y,n;</span><br><span class="line">cin&gt;&gt;y&gt;&gt;n;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=y;i&lt;y+<span class="number">130</span>;i++)</span><br><span class="line">&#123;<span class="comment">//假设上限为 130,能活到 130 岁 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q=i/<span class="number">1000</span>;<span class="comment">//千位 </span></span><br><span class="line"><span class="keyword">int</span> b=i/<span class="number">100</span>%<span class="number">10</span>;<span class="comment">//百位 </span></span><br><span class="line"><span class="keyword">int</span> s=i/<span class="number">10</span>%<span class="number">10</span>;<span class="comment">//十位 </span></span><br><span class="line"><span class="keyword">int</span> g=i%<span class="number">10</span>;<span class="comment">//个位</span></span><br><span class="line">set.<span class="built_in">insert</span>(g);</span><br><span class="line">set.<span class="built_in">insert</span>(s);</span><br><span class="line">set.<span class="built_in">insert</span>(b);</span><br><span class="line">set.<span class="built_in">insert</span>(q);</span><br><span class="line"><span class="keyword">if</span>(set.<span class="built_in">size</span>()==n)</span><br><span class="line">&#123;<span class="comment">//满足条件时退出 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %04d\n&quot;</span>,i-y,i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">set.<span class="built_in">clear</span>(); <span class="comment">//清空容器,方便下一次数据读入 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-032 Left-pad</title>
      <link href="/2021/01/20/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-032%20Left-pad/"/>
      <url>/2021/01/20/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-032%20Left-pad/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-032-Left-pad"><a href="#PTA-团队天梯赛║L1-032-Left-pad" class="headerlink" title="PTA 团队天梯赛║L1-032 Left-pad"></a>PTA 团队天梯赛║L1-032 <strong>Left-pad</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>根据新浪微博上的消息，有一位开发者不满 NPM（Node Package Manager）的做法，收回了自己的开源代码，其中包括一个叫 left-pad 的模块，就是这个模块把 javascript 里面的 React/Babel 干瘫痪了。这是个什么样的模块？就是在字符串前填充一些东西到一定的长度。例如用<code>*</code>去填充字符串<code>GPLT</code>，使之长度为 10，调用 left-pad 的结果就应该是<code>******GPLT</code>。Node 社区曾经对 left-pad 紧急发布了一个替代，被严重吐槽。下面就请你来实现一下这个模块。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<code>N</code>（≤104）和一个字符，分别是填充结果字符串的长度和用于填充的字符，中间以 1 个空格分开。第二行给出原始的非空字符串，以回车结束。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出结果字符串。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 _</span><br><span class="line">I love GPLT</span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">____I love GPLT</span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 *</span><br><span class="line">this is a sample for cut</span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>先比较输入字符串长度与输出字符数的大小，若字符串长度大于输出字符，则从 <code>字符串长度-输出字符数</code>处开始输出直至字符串结束，若字符串长度小于输出字符则先输出 <code>输出字符数-字符串长度</code> 个符号再输出字符串。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> num, dif;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    cin &gt;&gt; num &gt;&gt; c;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">length</span>()&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        dif = s.<span class="built_in">length</span>()-num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=dif; i&lt;s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dif = num-s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dif; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; c;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>在输入字符串时 <code>cin</code> 输入流遇到空字符会结束，现用 getchar() 清除缓冲区，利用 getline() 写入直到遇到换行符结束。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-027 出租</title>
      <link href="/2021/01/18/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-027%20%E5%87%BA%E7%A7%9F/"/>
      <url>/2021/01/18/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-027%20%E5%87%BA%E7%A7%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-027-出租"><a href="#PTA-团队天梯赛║L1-027-出租" class="headerlink" title="PTA 团队天梯赛║L1-027 出租"></a>PTA 团队天梯赛║L1-027 <strong>出租</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>下面是新浪微博上曾经很火的一张图：<br><img src="https://img-blog.csdnimg.cn/5f46c5bd115c468ba89f77aed0885be7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NDkyMTE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述 "><br>一时间网上一片求救声，急问这个怎么破。其实这段代码很简单，<code>index</code>数组就是<code>arr</code>数组的下标，<code>index[0]=2</code> 对应 <code>arr[2]=1</code>，<code>index[1]=0</code> 对应 <code>arr[0]=8</code>，<code>index[2]=3</code> 对应 <code>arr[3]=0</code>，以此类推…… 很容易得到电话号码是<code>18013820100</code>。</p><p>本题要求你编写一个程序，为任何一个电话号码生成这段代码 —— 事实上，只要生成最前面两行就可以了，后面内容是不变的。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个由 11 位数字组成的手机号码。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>为输入的号码生成代码的前两行，其中<code>arr</code>中的数字必须按递减顺序给出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18013820100</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[]&#123;8,3,2,1,0&#125;;</span><br><span class="line">int[] index = new int[]&#123;3,0,4,3,1,0,2,4,3,4,4&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>创建一个整型数组 a[10] 存放 <code>0~9</code> 在号码中出现的次数，写入字符串，将每一位上的字符转为数字后直接作为数组 a 的下标，让该位置上数量加一，统计出每个数字的出现次数。新建数组 arr[10]，将数组 a 中非零的元素下标降序写入 arr 数组，输出。然后挨个比对号码每一位上的数字与 arr 数组中的数字，若匹配则输出下标。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">11</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[s[i]-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>], num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">9</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            arr[num] = i;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int[] arr = new int[]&#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;num<span class="number">-1</span>) cout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&#125;;&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;int[] index = new int[]&#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">11</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;num; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]-<span class="string">&#x27;0&#x27;</span>==arr[j]) cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">10</span>) cout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&#125;;&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>在比较字符串 s 每一位与数组 arr 是否匹配时，忘记将字符转化为整型数，导致结果出错，谨记在比较时，两边的数据类型是否相同？</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-023 输出GPLT</title>
      <link href="/2021/01/16/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-023%20%E8%BE%93%E5%87%BAGPLT/"/>
      <url>/2021/01/16/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-023%20%E8%BE%93%E5%87%BAGPLT/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-023-输出-GPLT"><a href="#PTA-团队天梯赛║L1-023-输出-GPLT" class="headerlink" title="PTA 团队天梯赛║L1-023  输出 GPLT"></a>PTA 团队天梯赛║L1-023  <strong>输出 GPLT</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>给定一个长度不超过 10000 的、仅由英文字母构成的字符串。请将字符重新调整顺序，按<code>GPLTGPLT....</code>这样的顺序输出，并忽略其它字符。当然，四种字符（不区分大小写）的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按<code>GPLT</code>的顺序打印，直到所有字符都被输出。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个长度不超过 10000 的、仅由英文字母构成的非空字符串。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中按题目要求输出排序后的字符串。题目保证输出非空。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcTclnGloRgLrtLhgljkLhGFauPewSKgt</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPLTGPLTGLTGLGLL</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>先将输入的字符串全部转换为大写字母，然后对于 GPLT 四个字母计数，将每个字母出现的次数存放在 a[4] 中，然后按照顺序输出 <code>GPLT</code> ，每输出一个字母，该字母对应的计数减一，直到减为 0。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//存放 GPLT 出现次数</span></span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">length</span>(); i++) <span class="comment">//将字符串全部转化为大写字母，并计数</span></span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = <span class="built_in">toupper</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;G&#x27;</span>) a[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;P&#x27;</span>) a[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;L&#x27;</span>) a[<span class="number">2</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;T&#x27;</span>) a[<span class="number">3</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">while</span>(a[<span class="number">0</span>]!=<span class="number">0</span> || a[<span class="number">1</span>]!=<span class="number">0</span> || a[<span class="number">2</span>]!=<span class="number">0</span> || a[<span class="number">3</span>]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i]--;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;G&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;P&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;L&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>) cout &lt;&lt; <span class="string">&quot;T&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>利用了转换大写字母的函数 <em>toupper()</em> ，包含在头文件 <code>&lt;cctype&gt;</code> 中。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-020 帅到没朋友</title>
      <link href="/2021/01/14/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-020%20%E5%B8%85%E5%88%B0%E6%B2%A1%E6%9C%8B%E5%8F%8B/"/>
      <url>/2021/01/14/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-020%20%E5%B8%85%E5%88%B0%E6%B2%A1%E6%9C%8B%E5%8F%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-020-帅到没朋友"><a href="#PTA-团队天梯赛║L1-020-帅到没朋友" class="headerlink" title="PTA 团队天梯赛║L1-020 帅到没朋友"></a>PTA 团队天梯赛║L1-020 <strong>帅到没朋友</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<code>N</code>（≤100），是已知朋友圈的个数；随后<code>N</code>行，每行首先给出一个正整数<code>K</code>（≤1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数<code>M</code>（≤10000），为待查询的人数；随后一行中列出<code>M</code>个待查询的 ID，以空格分隔。</p><p>注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有<code>K</code>超过 1 的朋友圈里都至少有 2 个不同的人。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按输入的顺序输出那些帅到没朋友的人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出<code>No one is handsome</code>。</p><p>注意：同一个人可以被查询多次，但只输出一次。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 11111 22222 55555</span><br><span class="line">2 33333 44444</span><br><span class="line">4 55555 66666 99999 77777</span><br><span class="line">8</span><br><span class="line">55555 44444 10000 88888 22222 11111 23333 88888</span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000 88888 23333</span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 11111 22222 55555</span><br><span class="line">2 33333 44444</span><br><span class="line">4 55555 66666 99999 77777</span><br><span class="line">4</span><br><span class="line">55555 44444 22222 11111</span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No one is handsome</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>用一个大小为 100000 的整型数组存放朋友圈的人，将输入的 ID 作为下标，初始值均为 0。检测如果朋友圈的人数大于一，就将该朋友圈内所有人 ID 下标的数字置为 1。设置一个 sum 作为没朋友的总人数，检测是否帅的没朋友时，就检测该 ID 下标对应的数组元素是否为 0，若是，则输出该 ID，并且 sum++。最后判断 sum 是否为 0，若是，则证明没有帅到没朋友的人，输出 <code>No one is handsome</code> 。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n, k, m, K;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; m;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">1</span>) p[m] = <span class="number">1</span>; <span class="comment">//将有朋友的人做标记</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;K; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(p[m] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum != <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%05d&quot;</span>, m);  <span class="comment">//保证输出格式正确</span></span><br><span class="line">            p[m] = <span class="number">-1</span>;  <span class="comment">//避免重复</span></span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No one is handsome&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>第一次提交未得满分，发现是在输出时未控制格式，遇到诸如 <code>00038</code> 这样的 ID 会输出为 <code>38</code> ,后改进用<em>printf()</em> ，成功满分通过。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-019 谁先倒</title>
      <link href="/2021/01/14/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-019%20%E8%B0%81%E5%85%88%E5%80%92/"/>
      <url>/2021/01/14/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-019%20%E8%B0%81%E5%85%88%E5%80%92/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-019-谁先倒"><a href="#PTA-团队天梯赛║L1-019-谁先倒" class="headerlink" title="PTA 团队天梯赛║L1-019 谁先倒"></a>PTA 团队天梯赛║L1-019 <strong>谁先倒</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就输了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。</p><p>下面给出甲、乙两人的酒量（最多能喝多少杯不倒）和划拳记录，请你判断两个人谁先倒。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行先后给出甲、乙两人的酒量（不超过 100 的非负整数），以空格分隔。下一行给出一个正整数<code>N</code>（≤100），随后<code>N</code>行，每行给出一轮划拳的记录，格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">甲喊 甲划 乙喊 乙划</span><br></pre></td></tr></table></figure><p>其中<code>喊</code>是喊出的数字，<code>划</code>是划出的数字，均为不超过 100 的正整数（两只手一起划）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在第一行中输出先倒下的那个人：<code>A</code>代表甲，<code>B</code>代表乙。第二行中输出没倒的那个人喝了多少杯。题目保证有一个人倒下。注意程序处理到有人倒下就终止，后面的数据不必处理。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">6</span><br><span class="line">8 10 9 12</span><br><span class="line">5 10 5 10</span><br><span class="line">3 8 5 12</span><br><span class="line">12 18 1 13</span><br><span class="line">4 16 12 15</span><br><span class="line">15 1 1 16</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>用两个变量存储甲乙的酒量，甲乙再分别用两个变量存储为喊和划的数字，循环 <strong>N</strong> 次，判断两人喊的数字之和与谁划的数字相同，则该人酒量数字减一，当酒量数字小于 <strong>0</strong> 时 break，该人倒下输出名字，另一个人没倒的喝了多少杯可以用另一个人的酒量减去他剩余酒量。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> A,B;<span class="comment">//甲乙酒量</span></span><br><span class="line">cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line"><span class="keyword">int</span> a = A, b = B;<span class="comment">//a 和 b 用来记录 A 与 B 何时倒 </span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">0</span>, a2 = <span class="number">0</span>, b1 = <span class="number">0</span>, b2 = <span class="number">0</span>;<span class="comment">//甲喊 甲划 乙喊 乙划 </span></span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line"><span class="keyword">while</span>(N--)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; b1 &gt;&gt; b2; </span><br><span class="line"><span class="keyword">if</span>((a2 == a1+b1)&amp;&amp;(a2 != b2))<span class="comment">//A 输掉一轮</span></span><br><span class="line">&#123;</span><br><span class="line">a--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((b2 == a1+b1)&amp;&amp;(a2 != b2))<span class="comment">//B 输掉一轮</span></span><br><span class="line">&#123; </span><br><span class="line">b--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a&lt;<span class="number">0</span>)<span class="comment">//A 倒下</span></span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; endl &lt;&lt; B-b;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b&lt;<span class="number">0</span>)<span class="comment">//B 倒下</span></span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; endl &lt;&lt; A-a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>题目总体使用简单的 <em><strong>if</strong></em> 条件判断即可完成主要功能，逻辑清晰后代码并不难。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-017 到底有多二</title>
      <link href="/2021/01/13/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-017%20%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E4%BA%8C/"/>
      <url>/2021/01/13/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-017%20%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-017-到底有多二"><a href="#PTA-团队天梯赛║L1-017-到底有多二" class="headerlink" title="PTA 团队天梯赛║L1-017 到底有多二"></a>PTA 团队天梯赛║L1-017 <strong>到底有多二</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>一个整数“<strong>犯二的程度</strong>”定义为该数字中包含 2 的个数与其位数的比值。如果这个数是负数，则程度增加 0.5 倍；如果还是个偶数，则再增加 1 倍。例如数字<code>-13142223336</code>是个 11 位数，其中有 3 个 2，并且是负数，也是偶数，则它的犯二程度计算为：3/11×1.5×2×100%，约为 81.82%。本题就请你计算一个给定整数到底有多二。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个不超过 50 位的整数<code>N</code>。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出<code>N</code>犯二的程度，保留小数点后两位。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-13142223336</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">81.82%</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>设置两个倍数标志 <code>fu</code> 和 <code>ou</code> 初始值均为 <strong>1</strong> ，用字符串存储输入的整数，先判断第一位是否为 <strong>’-‘</strong> ，若是负数，更新 <code>fu</code> 为 <strong>1.5</strong> ，并在计算字符串长度时减一，然后判断该整数是否为偶数，若是，更新 <code>ou</code> 为 <strong>2</strong> 。然后遍历字符串计数 <strong>’2‘</strong> 的个数，根据题目要求计算得出结果，结果输出保留两位小数。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">float</span> fu = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ou = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> two = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)     <span class="comment">//判断负数</span></span><br><span class="line">    &#123;</span><br><span class="line">        fu = <span class="number">1.5</span>;</span><br><span class="line">        len -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((s[s.<span class="built_in">length</span>()<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>)%<span class="number">2</span> == <span class="number">0</span>)  <span class="comment">//判断偶数</span></span><br><span class="line">    &#123;</span><br><span class="line">        ou = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">length</span>(); i++)     <span class="comment">//计数 2 的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            two += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="built_in"><span class="keyword">double</span></span>(two)/<span class="built_in"><span class="keyword">double</span></span>(len) * fu * ou * <span class="number">100</span>;  <span class="comment">//强制转换为双浮点型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f%\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>题目难度不大，但是要注意最后输出两位小数，计算是不能用整型，需要强制转换一下数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-015 跟奥巴马一起画方块</title>
      <link href="/2021/01/13/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-015%20%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%94%BB%E6%96%B9%E5%9D%97/"/>
      <url>/2021/01/13/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-015%20%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%94%BB%E6%96%B9%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-015-跟奥巴马一起画方块"><a href="#PTA-团队天梯赛║L1-015-跟奥巴马一起画方块" class="headerlink" title="PTA 团队天梯赛║L1-015 跟奥巴马一起画方块"></a>PTA 团队天梯赛║L1-015 <strong>跟奥巴马一起画方块</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出正方形边长<em>N</em>（3≤<em>N</em>≤21）和组成正方形边的某种字符<code>C</code>，间隔一个空格。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出由给定字符<code>C</code>画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 a</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaaa</span><br><span class="line">aaaaaaaaaa</span><br><span class="line">aaaaaaaaaa</span><br><span class="line">aaaaaaaaaa</span><br><span class="line">aaaaaaaaaa</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>题目关键在于控制输出，因为是整数除以 2，所以四舍五入利用偶数直接除以，奇数将除以结果加一实现，然后用两层循环输出，内循环输出一行内所有字符，外循环输出空行保证有字符的行数是列数的 50%。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n, p;</span><br><span class="line">   <span class="keyword">char</span> c;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">   <span class="keyword">if</span>(n&lt;<span class="number">3</span> || n&gt;<span class="number">21</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) p = n/<span class="number">2</span>;  <span class="comment">//控制四舍五入</span></span><br><span class="line">   <span class="keyword">else</span> p = n/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;p; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           cout &lt;&lt; c;</span><br><span class="line">       &#125;</span><br><span class="line">       cout &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>题目难度不大，掌握好行与列输出的关系比较容易解题。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-011 A-B</title>
      <link href="/2021/01/12/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-011%20A-B/"/>
      <url>/2021/01/12/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-011%20A-B/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-011-A-B"><a href="#PTA-团队天梯赛║L1-011-A-B" class="headerlink" title="PTA 团队天梯赛║L1-011 A-B"></a>PTA 团队天梯赛║L1-011 A-B</h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>本题要求你计算 <em>A</em>−<em>B</em> 。不过麻烦的是，<em>A</em>和<em>B</em>都是字符串 —— 即从字符串<em>A</em>中把字符串<em>B</em>所包含的字符全删掉，剩下的字符组成的就是字符串 <em>A</em>−<em>B</em> 。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在 2 行中先后给出字符串<em>A</em>和<em>B</em>。两字符串的长度都不超过 104，并且保证每个字符串都是由可见的 ASCII 码和空白字符组成，最后以换行符结束。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中打印出<em>A</em>−<em>B</em>的结果字符串。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I love GPLT!  It&#x27;s a fun game!</span><br><span class="line">aeiou</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I lv GPLT!  It&#x27;s  fn gm!</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>设置一个 flag，暴力循环比较 a 字符串的每一个字符是否与 b 字符串中的字符相同，如果发现相同，flag 更新为 false，最后用 <strong>if(flag)</strong> 控制输出 a 字符串</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    <span class="built_in">getline</span>(cin,a);</span><br><span class="line">    <span class="built_in">getline</span>(cin,b);</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">size_t</span> len = a.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">size_t</span> len2 = b.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; ++j)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">if</span> (b[j] == a[i])</span><br><span class="line">&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line">            cout &lt;&lt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>程序时间复杂度为 O(n<sup>2</sup>),程序耗时很长<img src="https://img-blog.csdnimg.cn/20210303191915276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NDkyMTE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述 "></p><p>网上看到柳诺大神巧妙的方法将时间复杂度降到 O(n),思路与代码如下</p><blockquote><p><strong>分析：辣么多 ASCII 码也在 0<del>255 之间，所以用 book 数组标记所有的 ASCII 码～如果第二个字符出现了这个 ACSII 码那就标记为 1</del>然后输出的时候当 book 数组对应的那个 ASCII 为 1 的时候就跳过不输出～</strong></p><p><em>引自 <a href="https://www.liuchuo.net/archives/1597">https://www.liuchuo.net/archives/1597</a></em></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s, a;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="built_in">getline</span>(cin, a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); i++) book[a[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(book[s[i]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        cout &lt;&lt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试点 1 和 3 耗时大为降低<img src="https://img-blog.csdnimg.cn/20210303191537645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NDkyMTE4,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-009 N个数求和</title>
      <link href="/2021/01/06/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-009%20N%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C/"/>
      <url>/2021/01/06/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-009%20N%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><p>本题的要求很简单，就是求<code>N</code>个数字的和。麻烦的是，这些数字是以有理数<code>分子/分母</code>的形式给出的，你输出的和也必须是有理数的形式。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<code>N</code>（≤100）。随后一行按格式<code>a1/b1 a2/b2 ...</code>给出<code>N</code>个有理数。题目保证所有分子和分母都在长整型范围内。另外，负数的符号一定出现在分子前面。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出上述数字和的最简形式 —— 即将结果写成<code>整数部分 分数部分</code>，其中分数部分写成<code>分子/分母</code>，要求分子小于分母，且它们没有公因子。如果结果的整数部分为 0，则只输出分数部分。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2/5 4/15 1/30 -2/60 8/3</span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 1/3</span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4/3 2/3</span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="输入样例-3："><a href="#输入样例-3：" class="headerlink" title="输入样例 3："></a>输入样例 3：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1/3 -1/6 1/8</span><br></pre></td></tr></table></figure><h3 id="输出样例-3："><a href="#输出样例-3：" class="headerlink" title="输出样例 3："></a>输出样例 3：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7/24</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>分数的和问题归根结底是通分时求最小公倍数和最大公因数的问题，将分子和分母分开进行运算，先求出所有分母的最小公倍数作为通分后的分母，然后求出通分后的分子之和，最后化简即可</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> a, <span class="keyword">long</span> <span class="keyword">int</span> b)</span>    <span class="comment">//求最大公因数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a%b==<span class="number">0</span> ? b : <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>], b[<span class="number">100</span>]; <span class="comment">//存放输入的分子和分母</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> s1 = <span class="number">0</span>;     <span class="comment">//存放所有分数通分后的分子之和</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> s2 = <span class="number">1</span>;     <span class="comment">//存放当前分母最小的公倍数</span></span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d/%d&quot;</span>, &amp;a[i],&amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    s2 = b[<span class="number">0</span>];  <span class="comment">//将 b[0] 作为初始分母最小公倍数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)  <span class="comment">//求出分母的最小公倍数</span></span><br><span class="line">    &#123;</span><br><span class="line">        s2 = s2*b[i] / <span class="built_in">gcd</span>(s2,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)  <span class="comment">//求出通分后的分子之和</span></span><br><span class="line">    &#123;</span><br><span class="line">        s1 += s2/b[i] * a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> n = s1/s2; <span class="comment">//最后结果整数部分</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> m = <span class="built_in">abs</span>(s1%s2); <span class="comment">//余数</span></span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="comment">//结果为整数</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">0</span>)    <span class="comment">//n==0 时不输出 n</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1&lt;<span class="number">0</span>)    <span class="comment">//如果结果为负数</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; m/<span class="built_in">gcd</span>(s2,m) &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; s2/<span class="built_in">gcd</span>(s2,m) &lt;&lt; endl;     <span class="comment">//将 (分子/分母) 化到最简</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><ol><li>由于输入时要输入分数，对于输入格式有要求，要求是 <code>a/b</code> 的格式，因此引入头文件 <code>#include &lt;stdio.h&gt;</code> ，利用 C 语言中 <em>scanf()</em> 实现更灵活的输入操作。</li><li>由于求最小公倍数还有主函数内多次要求最大公因数，因此在主函数前写一个求最大公因数的全局函数大大方便了后续的操作。</li><li>最后输出结果控制的时候，起初如果测试数据为负数总会输出错误，后发现是化简部分余数未保持正，因此解决方案是引入头文件 <code>#include &lt;cmath&gt;</code> 中 <em>abs()</em> 取绝对值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-008 求整数段和</title>
      <link href="/2021/01/06/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-008%20%E6%B1%82%E6%95%B4%E6%95%B0%E6%AE%B5%E5%92%8C/"/>
      <url>/2021/01/06/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-008%20%E6%B1%82%E6%95%B4%E6%95%B0%E6%AE%B5%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-008-求整数段和"><a href="#PTA-团队天梯赛║L1-008-求整数段和" class="headerlink" title="PTA 团队天梯赛║L1-008 求整数段和"></a>PTA 团队天梯赛║L1-008 <strong>求整数段和</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><blockquote><p>给定两个整数<em>A</em>和<em>B</em>，输出从<em>A</em>到<em>B</em>的所有整数以及这些数的和。</p></blockquote><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出 2 个整数<em>A</em>和<em>B</em>，其中−100≤<em>A</em>≤<em>B</em>≤100，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先顺序输出从<em>A</em>到<em>B</em>的所有整数，每 5 个数字占一行，每个数字占 5 个字符宽度，向右对齐。最后在一行中按<code>Sum = X</code>的格式输出全部数字的和<code>X</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-3 8</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   -3   -2   -1    0    1</span><br><span class="line">    2    3    4    5    6</span><br><span class="line">    7    8</span><br><span class="line">Sum = 30</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>用循环打出两个数之间的所有整数较为简单，需要注意的是要按照题目要求控制打印的格式，可以使用 C 语言风格的 <em>printf()</em> 式样化规定字符较为方便控制输出。</p><blockquote><p>可以在“%”和字母之间插进数字表示最大<a href="https://baike.baidu.com/item/%E5%9C%BA%E5%AE%BD">场宽 </a>。</p><p>例如：%3d 表示输出 3 位整型数，不够 3 位右对齐。</p><p>%9.2f 表示输出场宽为 9 的浮点数，其中小数位为 2，整数位为 6，</p><p>小数点占一位，不够 9 位右对齐。</p></blockquote><p>之后五个数字一换行，利用对 5 取余的办法控制。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a; i &lt; b+<span class="number">1</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>,i); <span class="comment">//每个数字占 5 个字符宽度，向右对齐</span></span><br><span class="line">        sum += i;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(j%<span class="number">5</span> == <span class="number">0</span>) cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j%<span class="number">5</span> != <span class="number">0</span> ) &#123;cout &lt;&lt; endl;&#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>第一次提交只得了<strong>9</strong>分，提示格式错误扣了一分，查错发现原代码在输出最后的<code>Sum=</code>前直接输出了换行，如果要输出 5 的整数倍的数字，代码就会多出一空行，后加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(j%5 != 0 ) &#123;cout &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure><p>控制空行的输出，重新提交得到满分。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-007 念数字</title>
      <link href="/2021/01/05/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-007%20%E5%BF%B5%E6%95%B0%E5%AD%97/"/>
      <url>/2021/01/05/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-007%20%E5%BF%B5%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-007-念数字"><a href="#PTA-团队天梯赛║L1-007-念数字" class="headerlink" title="PTA 团队天梯赛║L1-007 念数字"></a>PTA 团队天梯赛║L1-007 <strong>念数字</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><blockquote><p>输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出<code>fu</code>字。十个数字对应的拼音如下：</p><p>0: ling    1: yi    2: er    3: san    4: si    5: wu    6:liu    7:qi    8: ba    9: jiu</p></blockquote><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个整数，如：<code>1234</code>。</p><p><strong>提示：整数包括负数、零和正数。</strong></p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如 <code>yi er san si</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-600</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fu liu ling ling</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>用户输入 <em>string</em> 类型数据，然后存放至 <em>char</em> 数组中，用 <em>switch</em> 判断输出相应位置的拼音</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; n.<span class="built_in">length</span>(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[j] = n[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; n.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (a[i])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;fu&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ling&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;yi&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;er&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;san&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;si&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;wu&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;liu&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;qi&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ba&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;jiu&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == n.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;cout &lt;&lt; endl; <span class="keyword">break</span>;&#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>题目难度不大，但是一开始走了弯路，第一次想法为用 <em>int</em> 存储输入的整数，直接判断每一位上的数字较为麻烦复杂，因此改换为先使用 <em>string</em> 类型转存 <em>char</em> 数组的方式，更加简单快捷。主要实现功能部分用 <em>switch</em> 来实现。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-006 连续因子</title>
      <link href="/2021/01/04/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-006%20%E8%BF%9E%E7%BB%AD%E5%9B%A0%E5%AD%90/"/>
      <url>/2021/01/04/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-006%20%E8%BF%9E%E7%BB%AD%E5%9B%A0%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-006-连续因子"><a href="#PTA-团队天梯赛║L1-006-连续因子" class="headerlink" title="PTA 团队天梯赛║L1-006 连续因子"></a>PTA 团队天梯赛║L1-006 <strong>连续因子</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><blockquote><p>一个正整数 <em>N</em> 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数 <em>N</em>，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。</p></blockquote><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个正整数 <em>N</em>（1&lt;<em>N</em>&lt;231）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按 <code>因子 1*因子 2*……*因子 k</code> 的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">630</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5*6*7</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>根据 N 的值的取值范围小于等于 2<sup>31</sup>，而这个值介于 12 的阶乘到 13 的阶乘之间，所以我们可以得到最大的值应该是 12 个数连续相乘，又因为 1 不计算在内，所以最多只要有 11 为连续因子即可。</p><p>用暴力的思想，我从 2、3、4…sqrt(N) 开始乘，连着乘以 11 位，10 位，9 位…以此类推。</p><p>即连续乘 <strong>11</strong> 位：</p><blockquote><p>2 3 4 5 6 7 8 9 10 11 12 相乘</p><p>3 4 5 6 7 8 9 10 11 12 13 相乘</p><p>…</p></blockquote><p>连续乘 <strong>10</strong> 位：</p><blockquote><p>2 3 4 5 6 7 8 9 10 11 相乘</p><p>3 4 5 6 7 8 9 10 11 12 相乘</p><p>…</p></blockquote><p>直到只有 <strong>1</strong> 位时，过程中只要有一个乘积 <strong>S</strong> 使得 <code>N%S==0</code>，就可以认为找到了连续因子。</p><p>为了优化代码，在每次乘的时候如果当前的乘积已经大于 <strong>N</strong> 了，就没有继续乘的必要了。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">sqrt</span>(N);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum;  <span class="comment">//注意数据类型！！</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">11</span>; len&gt;<span class="number">0</span>; len--)   <span class="comment">//用 len 控制连续因子个数，N 最多只能到 12 阶乘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n; i++) <span class="comment">//连续因子不包括 1，从 2 开始乘，最多乘到 N 的开方就足够</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=i; j&lt;len+i; j++)    <span class="comment">//从当前的 i 开始，乘以的个数为 len 的长度</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum*=j;</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;N) <span class="keyword">break</span>;    <span class="comment">//到这就没有必要往下算了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(N%sum==<span class="number">0</span>)    <span class="comment">//当前的 sum 值是 N 的一个因子</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; len &lt;&lt; endl &lt;&lt; i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>; k&lt;j; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; k;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p><img src="https://img-blog.csdnimg.cn/20210223221140638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NDkyMTE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述 "></p><p>v1.0 最后两个测试点没有通过，还没有想通是哪里出现问题。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-005 考试座位号</title>
      <link href="/2021/01/01/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-005%20%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/"/>
      <url>/2021/01/01/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-005%20%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-005-考试座位号"><a href="#PTA-团队天梯赛║L1-005-考试座位号" class="headerlink" title="PTA 团队天梯赛║L1-005 考试座位号"></a>PTA 团队天梯赛║L1-005 <strong>考试座位号</strong></h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><blockquote><p>每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。</p></blockquote><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 <em>N</em>（≤1000），随后 <em>N</em> 行，每行给出一个考生的信息：<code>准考证号 试机座位号 考试座位号</code>。其中<code>准考证号</code>由 16 位数字组成，座位从 1 到 <em>N</em> 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。</p><p>考生信息之后，给出一个正整数 <em>M</em>（≤<em>N</em>），随后一行中给出 <em>M</em> 个待查询的试机座位号码，以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3310120150912233 2 4</span><br><span class="line">3310120150912119 4 1</span><br><span class="line">3310120150912126 1 3</span><br><span class="line">3310120150912002 3 2</span><br><span class="line">2</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3310120150912002 2</span><br><span class="line">3310120150912119 1</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>利用结构体和 <em>vector</em> 容器结合，在输入的数据中找到符合条件的数据并输出。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span> <span class="comment">//创建一个结构体存储学生的准考证号以及试机和考试座位号</span></span><br><span class="line">    string num; <span class="comment">//准考证号</span></span><br><span class="line">    <span class="keyword">int</span> com1,com2; <span class="comment">//com1 为试机座位号，com2 为考试座位号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;   <span class="comment">//n 为考生数，m 为待查询的考生数目</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;stu&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i].num &gt;&gt; a[i].com1 &gt;&gt; a[i].com2;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> src; <span class="comment">//待查询的试机座位号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; src;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j].com1 == src)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; a[j].num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[j].com2 &lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>运用好 <em>vector</em> 容器后题目就变得较为简单了，题目难度不大。</p><p><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html"><em>vector</em> 简单的知识点 </a></p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-004 计算摄氏温度</title>
      <link href="/2021/01/01/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-004%20%E8%AE%A1%E7%AE%97%E6%91%84%E6%B0%8F%E6%B8%A9%E5%BA%A6/"/>
      <url>/2021/01/01/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-004%20%E8%AE%A1%E7%AE%97%E6%91%84%E6%B0%8F%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-004-计算摄氏温度"><a href="#PTA-团队天梯赛║L1-004-计算摄氏温度" class="headerlink" title="PTA 团队天梯赛║L1-004 计算摄氏温度"></a>PTA 团队天梯赛║L1-004 计算摄氏温度</h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><blockquote><p>给定一个华氏温度<em>F</em>，本题要求编写程序，计算对应的摄氏温度<em>C</em>。计算公式：<em>C</em>=5×(<em>F</em>−32)/9。题目保证输入与输出均在整型范围内。</p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行中给出一个华氏温度。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中按照格式“Celsius = C”输出对应的摄氏温度 C 的整数值。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">150</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Celsius = 65</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>该题为最简单的根据公式数制转换，注意题目要求 <em>保证输入与输出均在整型范围内</em>。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f,c;</span><br><span class="line">    cin &gt;&gt; f;</span><br><span class="line">    c = <span class="number">5</span>*(f<span class="number">-32</span>)/<span class="number">9</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Celsius = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、反思总结"><a href="#四、反思总结" class="headerlink" title="四、反思总结"></a>四、反思总结</h2><p>题目有一些简单了，注意细心不要搞错输出时候的要求，以防检查测试不通过。</p>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-003 个位数统计</title>
      <link href="/2020/12/30/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-003%20%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1.md/"/>
      <url>/2020/12/30/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-003%20%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1.md/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-002-打印沙漏"><a href="#PTA-团队天梯赛║L1-002-打印沙漏" class="headerlink" title="PTA 团队天梯赛║L1-002 打印沙漏"></a>PTA 团队天梯赛║L1-002 打印沙漏</h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><blockquote><p>给定一个 <em>k</em> 位整数 <em>N</em>=<em>d</em><sub>k−1</sub>10*<sup>k−1</sup><em>+⋯+<em>d</em><sub>1</sub>10<sup>1</sup>+<em>d</em><sub>0</sub> (0≤</em>d<sub>i</sub>*≤9, <em>i</em>=0,⋯,<em>k</em>−1, <em>d</em><sub>k−1</sub>&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 <em>N</em>=100311，则有 2 个 0，3 个 1，和 1 个 3。</p></blockquote><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 <em>N</em>。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对 <em>N</em> 中每一种不同的个位数字，以 <code>D:M</code> 的格式在一行中输出该位数字 <code>D</code> 及其在 <em>N</em> 中出现的次数 <code>M</code>。要求按 <code>D</code> 的升序输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100311</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:2</span><br><span class="line">1:3</span><br><span class="line">3:1</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>利用<strong>字符串</strong>解决该问题，首先以字符串的形式存储用户输入的数据，接着用一个 0~9 的字符数组存储各位上出现的数字次数，最后顺序输出字符数组中非零的数以及存储的出现次数。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) <span class="comment">//将输入数字的每一位数字所在的字符数组位置存储的次数加 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        num[s[i]-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; num[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、问题反思"><a href="#四、问题反思" class="headerlink" title="四、问题反思"></a>四、问题反思</h2><ol><li>起初使用 <em>int</em> 和 <em>long</em> 类型去存储测试用例，无法满足题目 1000 位数字的要求，且操作过程较为复杂，后转用 <em>string</em> 类型操作既简单又准确。</li><li><em>string</em> 类型的字符串长度不能使用 <em>strlen()</em> 的方法获得，需要使用包装好 string 类里的函数方法 <em>string.lengtn()</em> 来获取长度。</li></ol>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA团队天梯赛║L1-002 打印沙漏</title>
      <link href="/2020/12/30/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-002%20%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/"/>
      <url>/2020/12/30/PTA%E5%9B%A2%E9%98%9F%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%95%91L1-002%20%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="PTA-团队天梯赛║L1-002-打印沙漏"><a href="#PTA-团队天梯赛║L1-002-打印沙漏" class="headerlink" title="PTA 团队天梯赛║L1-002 打印沙漏"></a>PTA 团队天梯赛║L1-002 打印沙漏</h1><h2 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h2><blockquote><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定 17 个“*”，要求按下列格式打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line">***</span><br><span class="line">*</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p>所谓“沙漏形状”，是指<strong>每行输出奇数个符号</strong>；各行<strong>符号中心对齐</strong>；<strong>相邻两行符号数差 2</strong>；符号数先<strong>从大到小顺序递减到 1</strong>，再从小到大顺序递增；首尾符号数相等。</p><p>给定任意 N 个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p></blockquote><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行给出 1 个正整数 N（≤1000）和一个符号，中间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19 *</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><p>该题目为图形输出类的问题，关键是找到图形输出的规律，由题目找寻下述规律</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">沙漏形状行数必然是奇数 (1,3,5,...,2x+1) //x=0,1,2,3,...</span><br><span class="line">行数为 1 时，符号数为 1</span><br><span class="line">行数为 3 时，符号数为 7，即 1+2*3</span><br><span class="line">行数为 5 时，符号数为 17，即 1+2*3+2*5</span><br><span class="line">...</span><br><span class="line">行数为 i 时，符号数为 1+2*3+2*5+...+2*i</span><br></pre></td></tr></table></figure><p>因此，先设置打印的沙漏层数 <em>level</em> 和 沙漏符号数 <em>hourglass</em> 为 1(若用户输入符号数不为 0，则至少可以打印一层沙漏)，用 while 循环累加 <em>level</em> 和 <em>hourglass</em> 直到能打印最多符号，最后先打印上半部分以及最中心的一个符号，再打印剩余部分的沙漏。</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, level = <span class="number">1</span>; <span class="comment">//n 为用户输入的符号数，level 为打印的沙漏层数</span></span><br><span class="line">    <span class="keyword">int</span> hourglass = <span class="number">1</span>; <span class="comment">//沙漏符号数</span></span><br><span class="line">    <span class="keyword">char</span> c; <span class="comment">//用户输入的符号</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n / hourglass) <span class="comment">//累加寻找能打印的最大沙漏</span></span><br><span class="line">    &#123;</span><br><span class="line">        level += <span class="number">2</span>; <span class="comment">//层数上下各加一层</span></span><br><span class="line">        hourglass += <span class="number">2</span> * level; <span class="comment">//沙漏符号数也增加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//while 循环最后一次多加了一次要减去</span></span><br><span class="line">    hourglass -= <span class="number">2</span>*level; <span class="comment">//注意两个算式顺序不能调换</span></span><br><span class="line">    level -= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印上半个沙漏</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; level/<span class="number">2</span> + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k &lt; i; k++) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span> ;m &lt; level<span class="number">-2</span>*i;m++) cout &lt;&lt; c;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印下半个沙漏</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=level/<span class="number">2</span>; i &gt;<span class="number">0</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k &lt; i<span class="number">-1</span>; k++) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span> ;m &lt; level<span class="number">-2</span>*(i<span class="number">-1</span>); m++) cout &lt;&lt; c;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n - hourglass &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、问题反思"><a href="#四、问题反思" class="headerlink" title="四、问题反思"></a>四、问题反思</h2><ol><li>在 while 循环寻找能打印的最大沙漏时，最后减去多加的两层时算数顺序不能调换，第一次因为调换了两个算式顺序导致打印出的沙漏出错。</li><li>打印上半个沙漏时第一次尝试未将最中间一层考虑进去，将问题复杂化了。</li><li>做完打印沙漏部分却遗漏了最后一步输出剩下未使用的符号数，得意忘形，粗心大意了，以后做题中谨记戒骄戒躁，认真阅读题目，做完题后检查一下是否完成全部要求。</li></ol><hr><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> PTA刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PTA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
